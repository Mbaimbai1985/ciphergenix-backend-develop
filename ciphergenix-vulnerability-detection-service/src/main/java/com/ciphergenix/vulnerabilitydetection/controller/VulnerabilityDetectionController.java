package com.ciphergenix.vulnerabilitydetection.controller;

import com.ciphergenix.vulnerabilitydetection.dto.AdversarialDetectionRequest;
import com.ciphergenix.vulnerabilitydetection.dto.DataPoisoningDetectionRequest;
import com.ciphergenix.vulnerabilitydetection.model.DetectionResult;
import com.ciphergenix.vulnerabilitydetection.model.DetectionType;
import com.ciphergenix.vulnerabilitydetection.service.VulnerabilityDetectionService;
import io.micrometer.core.annotation.Timed;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@RestController
@RequestMapping("/api/v1/vulnerability-detection")
@CrossOrigin(origins = "*", maxAge = 3600)
public class VulnerabilityDetectionController {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityDetectionController.class);
    
    @Autowired
    private VulnerabilityDetectionService vulnerabilityDetectionService;
    
    /**
     * Data Poisoning Detection Endpoint
     */
    @PostMapping("/data-poisoning/detect")
    @Timed(value = "data_poisoning_detection", description = "Time taken for data poisoning detection")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<DetectionResult> detectDataPoisoning(@Valid @RequestBody DataPoisoningDetectionRequest request) {
        logger.info("Received data poisoning detection request for session: {}", request.getSessionId());
        
        try {
            DetectionResult result = vulnerabilityDetectionService.detectDataPoisoning(request);
            
            HttpStatus status = result.getIsThreatDetected() ? HttpStatus.OK : HttpStatus.OK;
            return ResponseEntity.status(status).body(result);
            
        } catch (Exception e) {
            logger.error("Error processing data poisoning detection request", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Adversarial Attack Detection Endpoint
     */
    @PostMapping("/adversarial/detect")
    @Timed(value = "adversarial_detection", description = "Time taken for adversarial attack detection")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<DetectionResult> detectAdversarialAttack(@Valid @RequestBody AdversarialDetectionRequest request) {
        logger.info("Received adversarial attack detection request for session: {}", request.getSessionId());
        
        try {
            DetectionResult result = vulnerabilityDetectionService.detectAdversarialAttack(request);
            
            HttpStatus status = result.getIsThreatDetected() ? HttpStatus.OK : HttpStatus.OK;
            return ResponseEntity.status(status).body(result);
            
        } catch (Exception e) {
            logger.error("Error processing adversarial attack detection request", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Comprehensive Vulnerability Analysis Endpoint
     */
    @PostMapping("/comprehensive-analysis")
    @Timed(value = "comprehensive_analysis", description = "Time taken for comprehensive vulnerability analysis")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<CompletableFuture<List<DetectionResult>>> performComprehensiveAnalysis(
            @RequestParam String sessionId,
            @RequestParam String modelId,
            @RequestBody Map<String, Object> analysisRequest) {
        
        logger.info("Received comprehensive analysis request for session: {}", sessionId);
        
        try {
            @SuppressWarnings("unchecked")
            List<List<Double>> dataset = (List<List<Double>>) analysisRequest.get("dataset");
            @SuppressWarnings("unchecked")
            Map<String, Object> baselineStats = (Map<String, Object>) analysisRequest.get("baselineStats");
            @SuppressWarnings("unchecked")
            List<Double> sampleInput = (List<Double>) analysisRequest.get("sampleInput");
            @SuppressWarnings("unchecked")
            Map<String, Object> modelMetadata = (Map<String, Object>) analysisRequest.get("modelMetadata");
            
            CompletableFuture<List<DetectionResult>> result = vulnerabilityDetectionService.performComprehensiveAnalysis(
                sessionId, dataset, baselineStats, sampleInput, modelId, modelMetadata);
            
            return ResponseEntity.accepted().body(result);
            
        } catch (Exception e) {
            logger.error("Error processing comprehensive analysis request", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get Detection Results by Session
     */
    @GetMapping("/results/session/{sessionId}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<List<DetectionResult>> getDetectionResultsBySession(@PathVariable String sessionId) {
        logger.info("Retrieving detection results for session: {}", sessionId);
        
        try {
            List<DetectionResult> results = vulnerabilityDetectionService.getDetectionResultsBySession(sessionId);
            return ResponseEntity.ok(results);
        } catch (Exception e) {
            logger.error("Error retrieving detection results for session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get Detection Results by Type
     */
    @GetMapping("/results/type/{detectionType}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<List<DetectionResult>> getDetectionResultsByType(@PathVariable DetectionType detectionType) {
        logger.info("Retrieving detection results for type: {}", detectionType);
        
        try {
            List<DetectionResult> results = vulnerabilityDetectionService.getDetectionResultsByType(detectionType);
            return ResponseEntity.ok(results);
        } catch (Exception e) {
            logger.error("Error retrieving detection results for type: {}", detectionType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get Recent Threats
     */
    @GetMapping("/threats/recent")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<List<DetectionResult>> getRecentThreats(@RequestParam(defaultValue = "24") int hours) {
        logger.info("Retrieving threats from the last {} hours", hours);
        
        try {
            List<DetectionResult> threats = vulnerabilityDetectionService.getRecentThreats(hours);
            return ResponseEntity.ok(threats);
        } catch (Exception e) {
            logger.error("Error retrieving recent threats", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get High-Risk Detections
     */
    @GetMapping("/threats/high-risk")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<DetectionResult>> getHighRiskDetections(
            @RequestParam(defaultValue = "0.7") double threshold,
            @RequestParam(defaultValue = "24") int hours) {
        
        logger.info("Retrieving high-risk detections with threshold {} from the last {} hours", threshold, hours);
        
        try {
            List<DetectionResult> highRiskDetections = vulnerabilityDetectionService.getHighRiskDetections(threshold, hours);
            return ResponseEntity.ok(highRiskDetections);
        } catch (Exception e) {
            logger.error("Error retrieving high-risk detections", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get Detection Statistics
     */
    @GetMapping("/statistics")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> getDetectionStatistics(@RequestParam(defaultValue = "24") int hours) {
        logger.info("Retrieving detection statistics for the last {} hours", hours);
        
        try {
            Map<String, Object> statistics = vulnerabilityDetectionService.getDetectionStatistics(hours);
            return ResponseEntity.ok(statistics);
        } catch (Exception e) {
            logger.error("Error retrieving detection statistics", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Start Real-time Monitoring
     */
    @PostMapping("/monitoring/start/{sessionId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, String>> startRealtimeMonitoring(@PathVariable String sessionId) {
        logger.info("Starting real-time monitoring for session: {}", sessionId);
        
        try {
            vulnerabilityDetectionService.startRealtimeMonitoring(sessionId);
            
            Map<String, String> response = Map.of(
                "status", "started",
                "sessionId", sessionId,
                "message", "Real-time monitoring started successfully"
            );
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Error starting real-time monitoring for session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Model Integrity Monitoring
     */
    @PostMapping("/model-integrity/monitor/{modelId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, String>> monitorModelIntegrity(@PathVariable String modelId) {
        logger.info("Starting model integrity monitoring for model: {}", modelId);
        
        try {
            vulnerabilityDetectionService.monitorModelIntegrity(modelId);
            
            Map<String, String> response = Map.of(
                "status", "started",
                "modelId", modelId,
                "message", "Model integrity monitoring started successfully"
            );
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Error starting model integrity monitoring for model: {}", modelId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Model Theft Detection
     */
    @PostMapping("/model-theft/detect/{modelId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, String>> detectModelTheft(
            @PathVariable String modelId,
            @RequestBody Map<String, Object> queryPatterns) {
        
        logger.info("Starting model theft detection for model: {}", modelId);
        
        try {
            vulnerabilityDetectionService.detectModelTheft(modelId, queryPatterns);
            
            Map<String, String> response = Map.of(
                "status", "started",
                "modelId", modelId,
                "message", "Model theft detection started successfully"
            );
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Error starting model theft detection for model: {}", modelId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Health Check Endpoint
     */
    @GetMapping("/health")
    public ResponseEntity<Map<String, String>> healthCheck() {
        Map<String, String> health = Map.of(
            "status", "UP",
            "service", "CipherGenix Vulnerability Detection Service",
            "timestamp", java.time.LocalDateTime.now().toString()
        );
        
        return ResponseEntity.ok(health);
    }
    
    /**
     * Service Information Endpoint
     */
    @GetMapping("/info")
    public ResponseEntity<Map<String, Object>> getServiceInfo() {
        Map<String, Object> info = Map.of(
            "serviceName", "CipherGenix Vulnerability Detection Service",
            "version", "1.0.0",
            "description", "AI Vulnerability Detection Engine for data poisoning and adversarial attack detection",
            "supportedDetectionTypes", DetectionType.values(),
            "endpoints", Map.of(
                "dataPoisoning", "/api/v1/vulnerability-detection/data-poisoning/detect",
                "adversarialAttack", "/api/v1/vulnerability-detection/adversarial/detect",
                "comprehensiveAnalysis", "/api/v1/vulnerability-detection/comprehensive-analysis",
                "statistics", "/api/v1/vulnerability-detection/statistics"
            )
        );
        
        return ResponseEntity.ok(info);
    }
}