package com.ciphergenix.vulnerabilitydetection.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Geolocation Service for CipherGenix AI Security Platform
 * 
 * Provides IP geolocation lookup and threat intelligence integration
 * for geographic threat analysis and blocking decisions.
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class GeolocationService {

    private final RestTemplate restTemplate;

    @Value("${ciphergenix.geolocation.api-key:}")
    private String geoLocationApiKey;

    @Value("${ciphergenix.geolocation.provider:ipapi}")
    private String geoLocationProvider;

    @Value("${ciphergenix.geolocation.enabled:true}")
    private boolean geoLocationEnabled;

    /**
     * Get geolocation information for an IP address
     */
    @Cacheable(value = "geolocation", key = "#ipAddress")
    public GeolocationInfo getGeolocation(String ipAddress) {
        if (!geoLocationEnabled) {
            return createMockGeolocation(ipAddress);
        }

        try {
            switch (geoLocationProvider.toLowerCase()) {
                case "ipapi" -> {
                    return getGeolocationFromIpApi(ipAddress);
                }
                case "ipstack" -> {
                    return getGeolocationFromIpStack(ipAddress);
                }
                case "ipgeolocation" -> {
                    return getGeolocationFromIpGeolocation(ipAddress);
                }
                default -> {
                    log.warn("Unknown geolocation provider: {}, using mock data", geoLocationProvider);
                    return createMockGeolocation(ipAddress);
                }
            }
        } catch (Exception e) {
            log.error("Error getting geolocation for IP: {}", ipAddress, e);
            return createMockGeolocation(ipAddress);
        }
    }

    /**
     * Get geolocation from IP-API.com (free tier)
     */
    private GeolocationInfo getGeolocationFromIpApi(String ipAddress) {
        try {
            String url = String.format("http://ip-api.com/json/%s?fields=status,country,countryCode,region,regionName,city,zip,lat,lon,timezone,isp,org,as,proxy,hosting", ipAddress);
            
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            Map<String, Object> data = response.getBody();

            if (data != null && "success".equals(data.get("status"))) {
                GeolocationInfo geoInfo = new GeolocationInfo();
                geoInfo.setIpAddress(ipAddress);
                geoInfo.setCountry((String) data.get("country"));
                geoInfo.setCountryCode((String) data.get("countryCode"));
                geoInfo.setRegion((String) data.get("regionName"));
                geoInfo.setRegionCode((String) data.get("region"));
                geoInfo.setCity((String) data.get("city"));
                geoInfo.setPostalCode((String) data.get("zip"));
                geoInfo.setLatitude(parseDouble(data.get("lat")));
                geoInfo.setLongitude(parseDouble(data.get("lon")));
                geoInfo.setTimezone((String) data.get("timezone"));
                geoInfo.setIsp((String) data.get("isp"));
                geoInfo.setOrganization((String) data.get("org"));
                geoInfo.setAsName((String) data.get("as"));
                
                // IP-API provides some security indicators
                geoInfo.setIsProxy(Boolean.TRUE.equals(data.get("proxy")));
                geoInfo.setIsHosting(Boolean.TRUE.equals(data.get("hosting")));
                
                // Add threat intelligence (simplified)
                enhanceWithThreatIntelligence(geoInfo);
                
                return geoInfo;
            }
        } catch (Exception e) {
            log.error("Error calling IP-API for IP: {}", ipAddress, e);
        }
        
        return createMockGeolocation(ipAddress);
    }

    /**
     * Get geolocation from IPStack (requires API key)
     */
    private GeolocationInfo getGeolocationFromIpStack(String ipAddress) {
        try {
            String url = String.format("http://api.ipstack.com/%s?access_key=%s&security=1", 
                                     ipAddress, geoLocationApiKey);
            
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            Map<String, Object> data = response.getBody();

            if (data != null) {
                GeolocationInfo geoInfo = new GeolocationInfo();
                geoInfo.setIpAddress(ipAddress);
                geoInfo.setCountry((String) data.get("country_name"));
                geoInfo.setCountryCode((String) data.get("country_code"));
                geoInfo.setRegion((String) data.get("region_name"));
                geoInfo.setRegionCode((String) data.get("region_code"));
                geoInfo.setCity((String) data.get("city"));
                geoInfo.setPostalCode((String) data.get("zip"));
                geoInfo.setLatitude(parseDouble(data.get("latitude")));
                geoInfo.setLongitude(parseDouble(data.get("longitude")));
                geoInfo.setTimezone((String) getNestedValue(data, "time_zone", "id"));
                
                // IPStack provides security data
                Map<String, Object> security = (Map<String, Object>) data.get("security");
                if (security != null) {
                    geoInfo.setIsProxy(Boolean.TRUE.equals(security.get("is_proxy")));
                    geoInfo.setIsVpn(Boolean.TRUE.equals(security.get("is_vpn")));
                    geoInfo.setIsTor(Boolean.TRUE.equals(security.get("is_tor")));
                }
                
                enhanceWithThreatIntelligence(geoInfo);
                
                return geoInfo;
            }
        } catch (Exception e) {
            log.error("Error calling IPStack for IP: {}", ipAddress, e);
        }
        
        return createMockGeolocation(ipAddress);
    }

    /**
     * Get geolocation from IPGeolocation (requires API key)
     */
    private GeolocationInfo getGeolocationFromIpGeolocation(String ipAddress) {
        try {
            String url = String.format("https://api.ipgeolocation.io/ipgeo?apiKey=%s&ip=%s&security=true", 
                                     geoLocationApiKey, ipAddress);
            
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            Map<String, Object> data = response.getBody();

            if (data != null) {
                GeolocationInfo geoInfo = new GeolocationInfo();
                geoInfo.setIpAddress(ipAddress);
                geoInfo.setCountry((String) data.get("country_name"));
                geoInfo.setCountryCode((String) data.get("country_code2"));
                geoInfo.setRegion((String) data.get("state_prov"));
                geoInfo.setCity((String) data.get("city"));
                geoInfo.setPostalCode((String) data.get("zipcode"));
                geoInfo.setLatitude(parseDouble(data.get("latitude")));
                geoInfo.setLongitude(parseDouble(data.get("longitude")));
                geoInfo.setTimezone((String) getNestedValue(data, "time_zone", "name"));
                geoInfo.setIsp((String) data.get("isp"));
                geoInfo.setOrganization((String) data.get("organization"));
                
                // IPGeolocation provides security data
                Map<String, Object> security = (Map<String, Object>) data.get("security");
                if (security != null) {
                    geoInfo.setIsProxy(Boolean.TRUE.equals(security.get("is_proxy")));
                    geoInfo.setIsVpn(Boolean.TRUE.equals(security.get("is_vpn")));
                    geoInfo.setIsTor(Boolean.TRUE.equals(security.get("is_tor")));
                }
                
                enhanceWithThreatIntelligence(geoInfo);
                
                return geoInfo;
            }
        } catch (Exception e) {
            log.error("Error calling IPGeolocation for IP: {}", ipAddress, e);
        }
        
        return createMockGeolocation(ipAddress);
    }

    /**
     * Enhance geolocation data with threat intelligence
     */
    private void enhanceWithThreatIntelligence(GeolocationInfo geoInfo) {
        try {
            // Add reputation scoring based on various factors
            double reputationScore = calculateReputationScore(geoInfo);
            geoInfo.setReputationScore(reputationScore);
            
            // Check against known malware/botnet indicators
            checkMalwareIndicators(geoInfo);
            
            // Add confidence scoring
            double confidenceScore = calculateConfidenceScore(geoInfo);
            geoInfo.setConfidenceScore(confidenceScore);
            
        } catch (Exception e) {
            log.error("Error enhancing geolocation with threat intelligence for IP: {}", 
                     geoInfo.getIpAddress(), e);
        }
    }

    /**
     * Calculate reputation score based on various factors
     */
    private double calculateReputationScore(GeolocationInfo geoInfo) {
        double score = 100.0; // Start with perfect score
        
        // Reduce score for suspicious characteristics
        if (geoInfo.getIsVpn()) score -= 20.0;
        if (geoInfo.getIsProxy()) score -= 25.0;
        if (geoInfo.getIsTor()) score -= 40.0;
        if (geoInfo.getIsHosting()) score -= 10.0;
        
        // Country-based risk assessment
        if (geoInfo.getCountry() != null) {
            score -= getCountryRiskPenalty(geoInfo.getCountry());
        }
        
        return Math.max(score, 0.0);
    }

    /**
     * Get country risk penalty
     */
    private double getCountryRiskPenalty(String country) {
        Map<String, Double> countryRiskPenalties = Map.of(
            "Unknown", 30.0,
            "Russia", 15.0,
            "China", 15.0,
            "North Korea", 50.0,
            "Iran", 20.0,
            "Ukraine", 10.0,
            "Belarus", 15.0
        );
        
        return countryRiskPenalties.getOrDefault(country, 0.0);
    }

    /**
     * Check for malware and botnet indicators
     */
    private void checkMalwareIndicators(GeolocationInfo geoInfo) {
        // This would typically check against threat intelligence feeds
        // For now, we'll use simplified heuristics
        
        // Check if hosting provider (common for malware hosting)
        if (geoInfo.getIsHosting() && geoInfo.getIsTor()) {
            geoInfo.setIsMalware(true);
        }
        
        // Check for known malicious ASNs or ISPs (simplified)
        String org = geoInfo.getOrganization();
        if (org != null) {
            String orgLower = org.toLowerCase();
            if (orgLower.contains("bulletproof") || 
                orgLower.contains("offshore") ||
                orgLower.contains("anonymous")) {
                geoInfo.setIsMalware(true);
            }
        }
        
        // Botnet detection heuristics
        if (geoInfo.getIsProxy() && geoInfo.getIsVpn()) {
            geoInfo.setIsBotnet(true);
        }
    }

    /**
     * Calculate confidence score for geolocation data
     */
    private double calculateConfidenceScore(GeolocationInfo geoInfo) {
        double confidence = 50.0; // Base confidence
        
        // Increase confidence based on available data
        if (geoInfo.getCountry() != null) confidence += 15.0;
        if (geoInfo.getRegion() != null) confidence += 10.0;
        if (geoInfo.getCity() != null) confidence += 10.0;
        if (geoInfo.getLatitude() != null && geoInfo.getLongitude() != null) confidence += 10.0;
        if (geoInfo.getIsp() != null) confidence += 5.0;
        
        return Math.min(confidence, 100.0);
    }

    /**
     * Create mock geolocation data for testing or fallback
     */
    private GeolocationInfo createMockGeolocation(String ipAddress) {
        GeolocationInfo geoInfo = new GeolocationInfo();
        geoInfo.setIpAddress(ipAddress);
        
        // Create realistic mock data based on IP patterns
        if (ipAddress.startsWith("192.168.") || ipAddress.startsWith("10.") || ipAddress.startsWith("172.")) {
            // Private IP
            geoInfo.setCountry("Local Network");
            geoInfo.setCountryCode("LAN");
            geoInfo.setRegion("Private");
            geoInfo.setCity("Internal");
            geoInfo.setConfidenceScore(100.0);
            geoInfo.setReputationScore(100.0);
        } else {
            // Public IP - create varied mock data
            String[] countries = {"United States", "China", "Russia", "Germany", "United Kingdom", "France", "Japan", "Brazil"};
            String[] countryCodes = {"US", "CN", "RU", "DE", "GB", "FR", "JP", "BR"};
            String[] cities = {"New York", "Beijing", "Moscow", "Berlin", "London", "Paris", "Tokyo", "SÃ£o Paulo"};
            
            int index = Math.abs(ipAddress.hashCode()) % countries.length;
            geoInfo.setCountry(countries[index]);
            geoInfo.setCountryCode(countryCodes[index]);
            geoInfo.setCity(cities[index]);
            geoInfo.setLatitude(ThreadLocalRandom.current().nextDouble(-90, 90));
            geoInfo.setLongitude(ThreadLocalRandom.current().nextDouble(-180, 180));
            
            // Random security characteristics for testing
            geoInfo.setIsVpn(ThreadLocalRandom.current().nextDouble() < 0.1);
            geoInfo.setIsProxy(ThreadLocalRandom.current().nextDouble() < 0.05);
            geoInfo.setIsTor(ThreadLocalRandom.current().nextDouble() < 0.02);
            geoInfo.setIsMalware(ThreadLocalRandom.current().nextDouble() < 0.01);
            geoInfo.setIsBotnet(ThreadLocalRandom.current().nextDouble() < 0.01);
            
            geoInfo.setConfidenceScore(ThreadLocalRandom.current().nextDouble(70, 95));
            geoInfo.setReputationScore(calculateReputationScore(geoInfo));
        }
        
        log.debug("Generated mock geolocation for IP: {} -> {}", ipAddress, geoInfo.getCountry());
        return geoInfo;
    }

    /**
     * Helper method to safely parse double values
     */
    private Double parseDouble(Object value) {
        if (value == null) return null;
        
        try {
            if (value instanceof Number) {
                return ((Number) value).doubleValue();
            }
            return Double.parseDouble(value.toString());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * Helper method to safely get nested values from Map
     */
    private Object getNestedValue(Map<String, Object> map, String... keys) {
        Object current = map;
        for (String key : keys) {
            if (current instanceof Map) {
                current = ((Map<?, ?>) current).get(key);
            } else {
                return null;
            }
        }
        return current;
    }

    /**
     * Geolocation Information class
     */
    public static class GeolocationInfo {
        private String ipAddress;
        private String country;
        private String countryCode;
        private String region;
        private String regionCode;
        private String city;
        private String postalCode;
        private Double latitude;
        private Double longitude;
        private String timezone;
        private String isp;
        private String organization;
        private String asName;
        private Long asNumber;
        private Boolean isVpn = false;
        private Boolean isProxy = false;
        private Boolean isTor = false;
        private Boolean isHosting = false;
        private Boolean isMalware = false;
        private Boolean isBotnet = false;
        private Double reputationScore;
        private Double confidenceScore;

        // Getters and setters
        public String getIpAddress() { return ipAddress; }
        public void setIpAddress(String ipAddress) { this.ipAddress = ipAddress; }
        
        public String getCountry() { return country; }
        public void setCountry(String country) { this.country = country; }
        
        public String getCountryCode() { return countryCode; }
        public void setCountryCode(String countryCode) { this.countryCode = countryCode; }
        
        public String getRegion() { return region; }
        public void setRegion(String region) { this.region = region; }
        
        public String getRegionCode() { return regionCode; }
        public void setRegionCode(String regionCode) { this.regionCode = regionCode; }
        
        public String getCity() { return city; }
        public void setCity(String city) { this.city = city; }
        
        public String getPostalCode() { return postalCode; }
        public void setPostalCode(String postalCode) { this.postalCode = postalCode; }
        
        public Double getLatitude() { return latitude; }
        public void setLatitude(Double latitude) { this.latitude = latitude; }
        
        public Double getLongitude() { return longitude; }
        public void setLongitude(Double longitude) { this.longitude = longitude; }
        
        public String getTimezone() { return timezone; }
        public void setTimezone(String timezone) { this.timezone = timezone; }
        
        public String getIsp() { return isp; }
        public void setIsp(String isp) { this.isp = isp; }
        
        public String getOrganization() { return organization; }
        public void setOrganization(String organization) { this.organization = organization; }
        
        public String getAsName() { return asName; }
        public void setAsName(String asName) { this.asName = asName; }
        
        public Long getAsNumber() { return asNumber; }
        public void setAsNumber(Long asNumber) { this.asNumber = asNumber; }
        
        public Boolean getIsVpn() { return isVpn; }
        public void setIsVpn(Boolean isVpn) { this.isVpn = isVpn; }
        
        public Boolean getIsProxy() { return isProxy; }
        public void setIsProxy(Boolean isProxy) { this.isProxy = isProxy; }
        
        public Boolean getIsTor() { return isTor; }
        public void setIsTor(Boolean isTor) { this.isTor = isTor; }
        
        public Boolean getIsHosting() { return isHosting; }
        public void setIsHosting(Boolean isHosting) { this.isHosting = isHosting; }
        
        public Boolean getIsMalware() { return isMalware; }
        public void setIsMalware(Boolean isMalware) { this.isMalware = isMalware; }
        
        public Boolean getIsBotnet() { return isBotnet; }
        public void setIsBotnet(Boolean isBotnet) { this.isBotnet = isBotnet; }
        
        public Double getReputationScore() { return reputationScore; }
        public void setReputationScore(Double reputationScore) { this.reputationScore = reputationScore; }
        
        public Double getConfidenceScore() { return confidenceScore; }
        public void setConfidenceScore(Double confidenceScore) { this.confidenceScore = confidenceScore; }
    }
}