package com.ciphergenix.vulnerabilitydetection.service;

import com.ciphergenix.vulnerabilitydetection.detector.AdversarialDetector;
import com.ciphergenix.vulnerabilitydetection.detector.DataPoisoningDetector;
import com.ciphergenix.vulnerabilitydetection.dto.AdversarialDetectionRequest;
import com.ciphergenix.vulnerabilitydetection.dto.DataPoisoningDetectionRequest;
import com.ciphergenix.vulnerabilitydetection.model.DetectionResult;
import com.ciphergenix.vulnerabilitydetection.model.DetectionType;
import com.ciphergenix.vulnerabilitydetection.repository.DetectionResultRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Service
@Transactional
public class VulnerabilityDetectionService {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityDetectionService.class);
    
    private static final String DETECTION_RESULTS_TOPIC = "ciphergenix-detection-results";
    private static final String THREAT_ALERTS_TOPIC = "ciphergenix-threat-alerts";
    
    @Autowired
    private DataPoisoningDetector dataPoisoningDetector;
    
    @Autowired
    private AdversarialDetector adversarialDetector;
    
    @Autowired
    private DetectionResultRepository detectionResultRepository;
    
    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    
    /**
     * Perform data poisoning detection
     */
    public DetectionResult detectDataPoisoning(DataPoisoningDetectionRequest request) {
        logger.info("Starting data poisoning detection for session: {}", request.getSessionId());
        
        try {
            // Perform detection
            DetectionResult result = dataPoisoningDetector.detectPoisoning(
                request.getSessionId(),
                request.getDataset(),
                request.getBaselineStats()
            );
            
            // Save result to database
            DetectionResult savedResult = detectionResultRepository.save(result);
            
            // Send result to Kafka
            sendDetectionResultToKafka(savedResult);
            
            // Send alert if threat detected
            if (savedResult.getIsThreatDetected()) {
                sendThreatAlert(savedResult);
            }
            
            logger.info("Data poisoning detection completed for session: {}. Result ID: {}", 
                       request.getSessionId(), savedResult.getId());
            
            return savedResult;
            
        } catch (Exception e) {
            logger.error("Error in data poisoning detection for session: {}", request.getSessionId(), e);
            throw new RuntimeException("Data poisoning detection failed", e);
        }
    }
    
    /**
     * Perform adversarial attack detection
     */
    public DetectionResult detectAdversarialAttack(AdversarialDetectionRequest request) {
        logger.info("Starting adversarial attack detection for session: {}", request.getSessionId());
        
        try {
            // Perform detection
            DetectionResult result = adversarialDetector.detectAdversarial(
                request.getSessionId(),
                request.getInputData(),
                request.getModelId(),
                request.getModelMetadata()
            );
            
            // Save result to database
            DetectionResult savedResult = detectionResultRepository.save(result);
            
            // Send result to Kafka
            sendDetectionResultToKafka(savedResult);
            
            // Send alert if threat detected
            if (savedResult.getIsThreatDetected()) {
                sendThreatAlert(savedResult);
            }
            
            logger.info("Adversarial attack detection completed for session: {}. Result ID: {}", 
                       request.getSessionId(), savedResult.getId());
            
            return savedResult;
            
        } catch (Exception e) {
            logger.error("Error in adversarial attack detection for session: {}", request.getSessionId(), e);
            throw new RuntimeException("Adversarial attack detection failed", e);
        }
    }
    
    /**
     * Perform comprehensive vulnerability analysis
     */
    @Async
    public CompletableFuture<List<DetectionResult>> performComprehensiveAnalysis(
            String sessionId, 
            List<List<Double>> dataset, 
            Map<String, Object> baselineStats,
            List<Double> sampleInput,
            String modelId,
            Map<String, Object> modelMetadata) {
        
        logger.info("Starting comprehensive vulnerability analysis for session: {}", sessionId);
        
        try {
            // Create requests
            DataPoisoningDetectionRequest dataPoisoningRequest = new DataPoisoningDetectionRequest(sessionId, dataset);
            dataPoisoningRequest.setBaselineStats(baselineStats);
            
            AdversarialDetectionRequest adversarialRequest = new AdversarialDetectionRequest(sessionId, sampleInput, modelId);
            adversarialRequest.setModelMetadata(modelMetadata);
            
            // Perform both detections
            DetectionResult dataPoisoningResult = detectDataPoisoning(dataPoisoningRequest);
            DetectionResult adversarialResult = detectAdversarialAttack(adversarialRequest);
            
            List<DetectionResult> results = List.of(dataPoisoningResult, adversarialResult);
            
            logger.info("Comprehensive vulnerability analysis completed for session: {}", sessionId);
            
            return CompletableFuture.completedFuture(results);
            
        } catch (Exception e) {
            logger.error("Error in comprehensive analysis for session: {}", sessionId, e);
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Get detection results by session ID
     */
    public List<DetectionResult> getDetectionResultsBySession(String sessionId) {
        return detectionResultRepository.findBySessionIdOrderByCreatedAtDesc(sessionId);
    }
    
    /**
     * Get detection results by type
     */
    public List<DetectionResult> getDetectionResultsByType(DetectionType detectionType) {
        return detectionResultRepository.findByDetectionTypeOrderByCreatedAtDesc(detectionType);
    }
    
    /**
     * Get recent threat detections
     */
    public List<DetectionResult> getRecentThreats(int hours) {
        LocalDateTime since = LocalDateTime.now().minusHours(hours);
        return detectionResultRepository.findByCreatedAtAfterOrderByCreatedAtDesc(since)
                .stream()
                .filter(DetectionResult::getIsThreatDetected)
                .toList();
    }
    
    /**
     * Get high-risk detections
     */
    public List<DetectionResult> getHighRiskDetections(double threshold, int hours) {
        LocalDateTime since = LocalDateTime.now().minusHours(hours);
        return detectionResultRepository.findHighRiskDetections(threshold, since);
    }
    
    /**
     * Get detection statistics
     */
    public Map<String, Object> getDetectionStatistics(int hours) {
        LocalDateTime since = LocalDateTime.now().minusHours(hours);
        List<Object[]> stats = detectionResultRepository.getDetectionStatistics(since);
        
        return Map.of(
            "totalDetections", detectionResultRepository.findByCreatedAtAfterOrderByCreatedAtDesc(since).size(),
            "threatDetections", detectionResultRepository.findByCreatedAtAfterOrderByCreatedAtDesc(since)
                    .stream().mapToLong(r -> r.getIsThreatDetected() ? 1 : 0).sum(),
            "byType", stats,
            "period", hours + " hours"
        );
    }
    
    /**
     * Real-time threat monitoring
     */
    @Async
    public void startRealtimeMonitoring(String sessionId) {
        logger.info("Starting real-time threat monitoring for session: {}", sessionId);
        
        // This would implement continuous monitoring logic
        // For now, we'll implement a placeholder that could be extended
        
        try {
            while (true) {
                // Check for new threats
                List<DetectionResult> recentThreats = getRecentThreats(1);
                
                if (!recentThreats.isEmpty()) {
                    logger.warn("Real-time monitoring detected {} threats in the last hour", recentThreats.size());
                    
                    // Send real-time alerts
                    for (DetectionResult threat : recentThreats) {
                        sendThreatAlert(threat);
                    }
                }
                
                // Sleep for monitoring interval
                Thread.sleep(60000); // Check every minute
                
            }
        } catch (InterruptedException e) {
            logger.info("Real-time monitoring stopped for session: {}", sessionId);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            logger.error("Error in real-time monitoring for session: {}", sessionId, e);
        }
    }
    
    /**
     * Send detection result to Kafka
     */
    private void sendDetectionResultToKafka(DetectionResult result) {
        try {
            kafkaTemplate.send(DETECTION_RESULTS_TOPIC, result.getSessionId(), result);
            logger.debug("Sent detection result to Kafka: {}", result.getId());
        } catch (Exception e) {
            logger.error("Error sending detection result to Kafka", e);
        }
    }
    
    /**
     * Send threat alert
     */
    private void sendThreatAlert(DetectionResult result) {
        try {
            Map<String, Object> alert = Map.of(
                "alertId", "ALERT_" + result.getId(),
                "sessionId", result.getSessionId(),
                "detectionType", result.getDetectionType().toString(),
                "threatScore", result.getThreatScore(),
                "timestamp", result.getCreatedAt(),
                "severity", calculateSeverity(result.getThreatScore()),
                "details", result.getDetectionDetails()
            );
            
            kafkaTemplate.send(THREAT_ALERTS_TOPIC, result.getSessionId(), alert);
            logger.warn("Sent threat alert for session: {} with score: {}", 
                       result.getSessionId(), result.getThreatScore());
        } catch (Exception e) {
            logger.error("Error sending threat alert", e);
        }
    }
    
    /**
     * Calculate severity level based on threat score
     */
    private String calculateSeverity(double threatScore) {
        if (threatScore >= 0.8) return "CRITICAL";
        if (threatScore >= 0.6) return "HIGH";
        if (threatScore >= 0.4) return "MEDIUM";
        if (threatScore >= 0.2) return "LOW";
        return "INFO";
    }
    
    /**
     * Monitor model integrity (integration with Model Integrity Service)
     */
    public void monitorModelIntegrity(String modelId) {
        logger.info("Starting model integrity monitoring for model: {}", modelId);
        
        try {
            // This would call the Model Integrity Service
            Map<String, Object> notification = new HashMap<>();
            notification.put("event", "INTEGRITY_MONITORING_STARTED");
            notification.put("modelId", modelId);
            notification.put("service", "vulnerability-detection");
            notification.put("timestamp", LocalDateTime.now());
            
            // Send notification to Kafka
            kafkaTemplate.send("ciphergenix-model-integrity-events", notification);
            
            logger.info("Model integrity monitoring initiated for model: {}", modelId);
            
        } catch (Exception e) {
            logger.error("Error starting model integrity monitoring for model: {}", modelId, e);
            throw new RuntimeException("Failed to start model integrity monitoring", e);
        }
    }
    
    /**
     * Detect model theft (integration with Model Integrity Service)
     */
    public void detectModelTheft(String modelId, Map<String, Object> queryPatterns) {
        logger.info("Starting model theft detection for model: {}", modelId);
        
        try {
            // Analyze query patterns for potential theft indicators
            Map<String, Object> analysis = analyzeQueryPatterns(queryPatterns);
            
            // Calculate theft probability
            double theftProbability = calculateTheftProbability(analysis);
            
            // Create detection result
            DetectionResult result = new DetectionResult();
            result.setSessionId("theft_detection_" + System.currentTimeMillis());
            result.setDetectionType(DetectionType.MODEL_THEFT);
            result.setThreatScore(theftProbability);
            result.setIsThreatDetected(theftProbability > 0.5);
            result.setConfidenceScore(0.85); // Confidence in theft detection
            result.setAlgorithmUsed("Query Pattern Analysis");
            result.setProcessingTimeMs(System.currentTimeMillis() - System.currentTimeMillis());
            result.setCreatedAt(LocalDateTime.now());
            result.setModelVersion("1.0");
            
            // Add analysis details
            Map<String, String> details = new HashMap<>();
            details.put("modelId", modelId);
            details.put("queryCount", String.valueOf(analysis.get("queryCount")));
            details.put("suspiciousPatterns", String.valueOf(analysis.get("suspiciousPatterns")));
            details.put("riskLevel", determineRiskLevel(theftProbability));
            result.setDetectionDetails(details);
            
            // Save result
            DetectionResult savedResult = detectionResultRepository.save(result);
            
            // Send to Kafka
            sendDetectionResultToKafka(savedResult);
            
            // Send alert if theft detected
            if (savedResult.getIsThreatDetected()) {
                sendThreatAlert(savedResult);
            }
            
            logger.info("Model theft detection completed for model: {} with probability: {}", 
                       modelId, theftProbability);
            
        } catch (Exception e) {
            logger.error("Error in model theft detection for model: {}", modelId, e);
            throw new RuntimeException("Failed to detect model theft", e);
        }
    }
    
    /**
     * Analyze query patterns for theft indicators
     */
    private Map<String, Object> analyzeQueryPatterns(Map<String, Object> queryPatterns) {
        Map<String, Object> analysis = new HashMap<>();
        
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> queries = (List<Map<String, Object>>) queryPatterns.getOrDefault("queries", new ArrayList<>());
        
        // Basic analysis metrics
        int queryCount = queries.size();
        int uniqueQueries = (int) queries.stream().map(Object::toString).distinct().count();
        double diversityRatio = queryCount > 0 ? (double) uniqueQueries / queryCount : 0.0;
        
        // Identify suspicious patterns
        int suspiciousPatterns = 0;
        if (queryCount > 1000) suspiciousPatterns++; // High volume
        if (diversityRatio < 0.1) suspiciousPatterns++; // Low diversity
        if (queries.stream().anyMatch(q -> q.toString().contains("extract"))) suspiciousPatterns++; // Suspicious keywords
        
        analysis.put("queryCount", queryCount);
        analysis.put("uniqueQueries", uniqueQueries);
        analysis.put("diversityRatio", diversityRatio);
        analysis.put("suspiciousPatterns", suspiciousPatterns);
        
        return analysis;
    }
    
    /**
     * Calculate theft probability based on analysis
     */
    private double calculateTheftProbability(Map<String, Object> analysis) {
        int queryCount = (Integer) analysis.get("queryCount");
        double diversityRatio = (Double) analysis.get("diversityRatio");
        int suspiciousPatterns = (Integer) analysis.get("suspiciousPatterns");
        
        double probability = 0.0;
        
        // High query volume increases probability
        if (queryCount > 1000) probability += 0.3;
        else if (queryCount > 500) probability += 0.2;
        else if (queryCount > 100) probability += 0.1;
        
        // Low diversity increases probability
        if (diversityRatio < 0.1) probability += 0.4;
        else if (diversityRatio < 0.3) probability += 0.2;
        
        // Suspicious patterns increase probability
        probability += suspiciousPatterns * 0.15;
        
        return Math.min(1.0, probability);
    }
    
    /**
     * Determine risk level based on theft probability
     */
    private String determineRiskLevel(double probability) {
        if (probability > 0.8) return "CRITICAL";
        if (probability > 0.6) return "HIGH";
        if (probability > 0.4) return "MEDIUM";
        return "LOW";
    }
}