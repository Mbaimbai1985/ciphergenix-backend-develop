package com.ciphergenix.vulnerabilitydetection.service;

import com.ciphergenix.vulnerabilitydetection.detector.AdversarialDetector;
import com.ciphergenix.vulnerabilitydetection.detector.DataPoisoningDetector;
import com.ciphergenix.vulnerabilitydetection.dto.AdversarialDetectionRequest;
import com.ciphergenix.vulnerabilitydetection.dto.DataPoisoningDetectionRequest;
import com.ciphergenix.vulnerabilitydetection.model.DetectionResult;
import com.ciphergenix.vulnerabilitydetection.model.DetectionType;
import com.ciphergenix.vulnerabilitydetection.repository.DetectionResultRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Service
@Transactional
public class VulnerabilityDetectionService {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityDetectionService.class);
    
    private static final String DETECTION_RESULTS_TOPIC = "ciphergenix-detection-results";
    private static final String THREAT_ALERTS_TOPIC = "ciphergenix-threat-alerts";
    
    @Autowired
    private DataPoisoningDetector dataPoisoningDetector;
    
    @Autowired
    private AdversarialDetector adversarialDetector;
    
    @Autowired
    private DetectionResultRepository detectionResultRepository;
    
    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    
    /**
     * Perform data poisoning detection
     */
    public DetectionResult detectDataPoisoning(DataPoisoningDetectionRequest request) {
        logger.info("Starting data poisoning detection for session: {}", request.getSessionId());
        
        try {
            // Perform detection
            DetectionResult result = dataPoisoningDetector.detectPoisoning(
                request.getSessionId(),
                request.getDataset(),
                request.getBaselineStats()
            );
            
            // Save result to database
            DetectionResult savedResult = detectionResultRepository.save(result);
            
            // Send result to Kafka
            sendDetectionResultToKafka(savedResult);
            
            // Send alert if threat detected
            if (savedResult.getIsThreatDetected()) {
                sendThreatAlert(savedResult);
            }
            
            logger.info("Data poisoning detection completed for session: {}. Result ID: {}", 
                       request.getSessionId(), savedResult.getId());
            
            return savedResult;
            
        } catch (Exception e) {
            logger.error("Error in data poisoning detection for session: {}", request.getSessionId(), e);
            throw new RuntimeException("Data poisoning detection failed", e);
        }
    }
    
    /**
     * Perform adversarial attack detection
     */
    public DetectionResult detectAdversarialAttack(AdversarialDetectionRequest request) {
        logger.info("Starting adversarial attack detection for session: {}", request.getSessionId());
        
        try {
            // Perform detection
            DetectionResult result = adversarialDetector.detectAdversarial(
                request.getSessionId(),
                request.getInputData(),
                request.getModelId(),
                request.getModelMetadata()
            );
            
            // Save result to database
            DetectionResult savedResult = detectionResultRepository.save(result);
            
            // Send result to Kafka
            sendDetectionResultToKafka(savedResult);
            
            // Send alert if threat detected
            if (savedResult.getIsThreatDetected()) {
                sendThreatAlert(savedResult);
            }
            
            logger.info("Adversarial attack detection completed for session: {}. Result ID: {}", 
                       request.getSessionId(), savedResult.getId());
            
            return savedResult;
            
        } catch (Exception e) {
            logger.error("Error in adversarial attack detection for session: {}", request.getSessionId(), e);
            throw new RuntimeException("Adversarial attack detection failed", e);
        }
    }
    
    /**
     * Perform comprehensive vulnerability analysis
     */
    @Async
    public CompletableFuture<List<DetectionResult>> performComprehensiveAnalysis(
            String sessionId, 
            List<List<Double>> dataset, 
            Map<String, Object> baselineStats,
            List<Double> sampleInput,
            String modelId,
            Map<String, Object> modelMetadata) {
        
        logger.info("Starting comprehensive vulnerability analysis for session: {}", sessionId);
        
        try {
            // Create requests
            DataPoisoningDetectionRequest dataPoisoningRequest = new DataPoisoningDetectionRequest(sessionId, dataset);
            dataPoisoningRequest.setBaselineStats(baselineStats);
            
            AdversarialDetectionRequest adversarialRequest = new AdversarialDetectionRequest(sessionId, sampleInput, modelId);
            adversarialRequest.setModelMetadata(modelMetadata);
            
            // Perform both detections
            DetectionResult dataPoisoningResult = detectDataPoisoning(dataPoisoningRequest);
            DetectionResult adversarialResult = detectAdversarialAttack(adversarialRequest);
            
            List<DetectionResult> results = List.of(dataPoisoningResult, adversarialResult);
            
            logger.info("Comprehensive vulnerability analysis completed for session: {}", sessionId);
            
            return CompletableFuture.completedFuture(results);
            
        } catch (Exception e) {
            logger.error("Error in comprehensive analysis for session: {}", sessionId, e);
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Get detection results by session ID
     */
    public List<DetectionResult> getDetectionResultsBySession(String sessionId) {
        return detectionResultRepository.findBySessionIdOrderByCreatedAtDesc(sessionId);
    }
    
    /**
     * Get detection results by type
     */
    public List<DetectionResult> getDetectionResultsByType(DetectionType detectionType) {
        return detectionResultRepository.findByDetectionTypeOrderByCreatedAtDesc(detectionType);
    }
    
    /**
     * Get recent threat detections
     */
    public List<DetectionResult> getRecentThreats(int hours) {
        LocalDateTime since = LocalDateTime.now().minusHours(hours);
        return detectionResultRepository.findByCreatedAtAfterOrderByCreatedAtDesc(since)
                .stream()
                .filter(DetectionResult::getIsThreatDetected)
                .toList();
    }
    
    /**
     * Get high-risk detections
     */
    public List<DetectionResult> getHighRiskDetections(double threshold, int hours) {
        LocalDateTime since = LocalDateTime.now().minusHours(hours);
        return detectionResultRepository.findHighRiskDetections(threshold, since);
    }
    
    /**
     * Get detection statistics
     */
    public Map<String, Object> getDetectionStatistics(int hours) {
        LocalDateTime since = LocalDateTime.now().minusHours(hours);
        List<Object[]> stats = detectionResultRepository.getDetectionStatistics(since);
        
        return Map.of(
            "totalDetections", detectionResultRepository.findByCreatedAtAfterOrderByCreatedAtDesc(since).size(),
            "threatDetections", detectionResultRepository.findByCreatedAtAfterOrderByCreatedAtDesc(since)
                    .stream().mapToLong(r -> r.getIsThreatDetected() ? 1 : 0).sum(),
            "byType", stats,
            "period", hours + " hours"
        );
    }
    
    /**
     * Real-time threat monitoring
     */
    @Async
    public void startRealtimeMonitoring(String sessionId) {
        logger.info("Starting real-time threat monitoring for session: {}", sessionId);
        
        // This would implement continuous monitoring logic
        // For now, we'll implement a placeholder that could be extended
        
        try {
            while (true) {
                // Check for new threats
                List<DetectionResult> recentThreats = getRecentThreats(1);
                
                if (!recentThreats.isEmpty()) {
                    logger.warn("Real-time monitoring detected {} threats in the last hour", recentThreats.size());
                    
                    // Send real-time alerts
                    for (DetectionResult threat : recentThreats) {
                        sendThreatAlert(threat);
                    }
                }
                
                // Sleep for monitoring interval
                Thread.sleep(60000); // Check every minute
                
            }
        } catch (InterruptedException e) {
            logger.info("Real-time monitoring stopped for session: {}", sessionId);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            logger.error("Error in real-time monitoring for session: {}", sessionId, e);
        }
    }
    
    /**
     * Send detection result to Kafka
     */
    private void sendDetectionResultToKafka(DetectionResult result) {
        try {
            kafkaTemplate.send(DETECTION_RESULTS_TOPIC, result.getSessionId(), result);
            logger.debug("Sent detection result to Kafka: {}", result.getId());
        } catch (Exception e) {
            logger.error("Error sending detection result to Kafka", e);
        }
    }
    
    /**
     * Send threat alert
     */
    private void sendThreatAlert(DetectionResult result) {
        try {
            Map<String, Object> alert = Map.of(
                "alertId", "ALERT_" + result.getId(),
                "sessionId", result.getSessionId(),
                "detectionType", result.getDetectionType().toString(),
                "threatScore", result.getThreatScore(),
                "timestamp", result.getCreatedAt(),
                "severity", calculateSeverity(result.getThreatScore()),
                "details", result.getDetectionDetails()
            );
            
            kafkaTemplate.send(THREAT_ALERTS_TOPIC, result.getSessionId(), alert);
            logger.warn("Sent threat alert for session: {} with score: {}", 
                       result.getSessionId(), result.getThreatScore());
        } catch (Exception e) {
            logger.error("Error sending threat alert", e);
        }
    }
    
    /**
     * Calculate severity level based on threat score
     */
    private String calculateSeverity(double threatScore) {
        if (threatScore >= 0.8) return "CRITICAL";
        if (threatScore >= 0.6) return "HIGH";
        if (threatScore >= 0.4) return "MEDIUM";
        if (threatScore >= 0.2) return "LOW";
        return "INFO";
    }
    
    /**
     * Model integrity monitoring (placeholder for future implementation)
     */
    public void monitorModelIntegrity(String modelId) {
        logger.info("Starting model integrity monitoring for model: {}", modelId);
        // Implementation would go here
    }
    
    /**
     * Model theft detection (placeholder for future implementation)
     */
    public void detectModelTheft(String modelId, Map<String, Object> queryPatterns) {
        logger.info("Starting model theft detection for model: {}", modelId);
        // Implementation would go here
    }
}