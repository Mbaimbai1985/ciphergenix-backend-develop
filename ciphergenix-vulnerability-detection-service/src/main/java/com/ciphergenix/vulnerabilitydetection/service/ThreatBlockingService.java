package com.ciphergenix.vulnerabilitydetection.service;

import com.ciphergenix.vulnerabilitydetection.model.*;
import com.ciphergenix.vulnerabilitydetection.repository.ThreatBlockRepository;
import com.ciphergenix.vulnerabilitydetection.repository.GeoThreatLogRepository;
import com.ciphergenix.vulnerabilitydetection.repository.ThreatLocationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Pattern;

/**
 * Threat Blocking Service for CipherGenix AI Security Platform
 * 
 * Provides real-time threat detection, automated blocking, and response
 * capabilities with geographic threat intelligence integration.
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class ThreatBlockingService {

    private final ThreatBlockRepository threatBlockRepository;
    private final GeoThreatLogRepository geoThreatLogRepository;
    private final ThreatLocationRepository threatLocationRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final GeolocationService geolocationService;

    @Value("${ciphergenix.security.auto-block.enabled:true}")
    private boolean autoBlockEnabled;

    @Value("${ciphergenix.security.auto-block.threshold-score:7.5}")
    private double autoBlockThresholdScore;

    @Value("${ciphergenix.security.auto-block.threat-count-threshold:10}")
    private int threatCountThreshold;

    @Value("${ciphergenix.security.auto-block.default-duration-minutes:60}")
    private int defaultBlockDurationMinutes;

    @Value("${ciphergenix.security.permanent-block.threshold-score:9.5}")
    private double permanentBlockThresholdScore;

    // IP Address validation patterns
    private static final Pattern IPV4_PATTERN = Pattern.compile(
        "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
    );

    private static final Pattern IPV6_PATTERN = Pattern.compile(
        "^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$"
    );

    // Whitelisted IP ranges (private networks, trusted sources)
    private final Set<String> whitelistedRanges = Set.of(
        "10.0.0.0/8",
        "172.16.0.0/12", 
        "192.168.0.0/16",
        "127.0.0.0/8"
    );

    /**
     * Check if an IP address should be blocked
     */
    public CompletableFuture<BlockDecision> checkIpForBlocking(String ipAddress) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Check if IP is already blocked
                Optional<ThreatBlock> existingBlock = threatBlockRepository.findActiveBlockByIp(ipAddress);
                if (existingBlock.isPresent()) {
                    ThreatBlock block = existingBlock.get();
                    if (block.isCurrentlyBlocked()) {
                        // Update blocked attempts counter
                        block.setBlockedAttempts(block.getBlockedAttempts() + 1);
                        block.setLastSeen(LocalDateTime.now());
                        threatBlockRepository.save(block);
                        
                        return new BlockDecision(true, block.getBlockReason().toString(), 
                                               block.getRemainingBlockTimeMinutes(), block);
                    }
                }

                // Check if IP is whitelisted
                if (isWhitelisted(ipAddress)) {
                    return new BlockDecision(false, "IP is whitelisted", 0, null);
                }

                // Analyze threat level for this IP
                ThreatAnalysis analysis = analyzeThreatLevel(ipAddress);
                
                // Make blocking decision based on analysis
                if (shouldBlockIp(analysis)) {
                    ThreatBlock block = createThreatBlock(ipAddress, analysis);
                    return new BlockDecision(true, block.getBlockReason().toString(), 
                                           block.getRemainingBlockTimeMinutes(), block);
                }

                return new BlockDecision(false, "IP passed security checks", 0, null);
                
            } catch (Exception e) {
                log.error("Error checking IP for blocking: {}", ipAddress, e);
                return new BlockDecision(false, "Error during security check", 0, null);
            }
        });
    }

    /**
     * Analyze threat level for an IP address
     */
    private ThreatAnalysis analyzeThreatLevel(String ipAddress) {
        ThreatAnalysis analysis = new ThreatAnalysis();
        analysis.setIpAddress(ipAddress);

        try {
            // Get geographic information
            GeolocationInfo geoInfo = geolocationService.getGeolocation(ipAddress);
            if (geoInfo != null) {
                analysis.setCountry(geoInfo.getCountry());
                analysis.setRegion(geoInfo.getRegion());
                analysis.setCity(geoInfo.getCity());
                analysis.setLatitude(geoInfo.getLatitude());
                analysis.setLongitude(geoInfo.getLongitude());
                analysis.setIsVpn(geoInfo.getIsVpn());
                analysis.setIsProxy(geoInfo.getIsProxy());
                analysis.setIsTor(geoInfo.getIsTor());
                analysis.setIsMalware(geoInfo.getIsMalware());
                analysis.setIsBotnet(geoInfo.getIsBotnet());
            }

            // Check recent threat history for this IP
            List<GeoThreatLog> recentThreats = geoThreatLogRepository
                .findRecentThreatsByIp(ipAddress, LocalDateTime.now().minusHours(24));
            
            analysis.setRecentThreatCount(recentThreats.size());
            
            // Calculate threat score based on various factors
            double threatScore = calculateThreatScore(analysis, recentThreats);
            analysis.setThreatScore(threatScore);

            // Determine severity level
            ThreatLocation.SeverityLevel severity = determineSeverityLevel(threatScore, analysis);
            analysis.setSeverityLevel(severity);

            // Check if IP is from a known threat location
            Optional<ThreatLocation> knownThreatLocation = threatLocationRepository
                .findByIpAddress(ipAddress);
            if (knownThreatLocation.isPresent()) {
                ThreatLocation location = knownThreatLocation.get();
                analysis.setThreatScore(Math.max(analysis.getThreatScore(), location.getRiskScore()));
                analysis.setPreviousThreats(location.getThreatCount());
            }

        } catch (Exception e) {
            log.error("Error analyzing threat level for IP: {}", ipAddress, e);
            analysis.setThreatScore(5.0); // Default moderate risk
            analysis.setSeverityLevel(ThreatLocation.SeverityLevel.MEDIUM);
        }

        return analysis;
    }

    /**
     * Calculate threat score based on multiple factors
     */
    private double calculateThreatScore(ThreatAnalysis analysis, List<GeoThreatLog> recentThreats) {
        double score = 0.0;

        // Base score from recent threat activity
        score += analysis.getRecentThreatCount() * 0.5;

        // Score from geographic risk factors
        if (analysis.getIsVpn()) score += 1.0;
        if (analysis.getIsProxy()) score += 1.5;
        if (analysis.getIsTor()) score += 3.0;
        if (analysis.getIsMalware()) score += 5.0;
        if (analysis.getIsBotnet()) score += 4.0;

        // Score from threat patterns
        Map<ThreatLocation.ThreatType, Long> threatTypeCounts = new HashMap<>();
        for (GeoThreatLog threat : recentThreats) {
            threatTypeCounts.merge(threat.getThreatType(), 1L, Long::sum);
        }

        // Higher scores for more dangerous threat types
        for (Map.Entry<ThreatLocation.ThreatType, Long> entry : threatTypeCounts.entrySet()) {
            switch (entry.getKey()) {
                case DATA_POISONING -> score += entry.getValue() * 2.0;
                case ADVERSARIAL_ATTACK -> score += entry.getValue() * 2.5;
                case MODEL_THEFT -> score += entry.getValue() * 3.0;
                case INJECTION_ATTACK -> score += entry.getValue() * 2.0;
                case BACKDOOR_ATTACK -> score += entry.getValue() * 3.5;
                default -> score += entry.getValue() * 1.0;
            }
        }

        // Score from frequency (rapid repeated attempts)
        if (analysis.getRecentThreatCount() > 20) score += 3.0;
        else if (analysis.getRecentThreatCount() > 10) score += 2.0;
        else if (analysis.getRecentThreatCount() > 5) score += 1.0;

        // Geographic risk assessment
        if (analysis.getCountry() != null) {
            score += getCountryRiskScore(analysis.getCountry());
        }

        return Math.min(score, 10.0); // Cap at 10.0
    }

    /**
     * Get risk score for a country (simplified example)
     */
    private double getCountryRiskScore(String country) {
        // This could be configurable or based on threat intelligence feeds
        Map<String, Double> countryRiskScores = Map.of(
            "Unknown", 1.0,
            "Russia", 0.5,
            "China", 0.5,
            "North Korea", 2.0,
            "Iran", 1.0
        );
        
        return countryRiskScores.getOrDefault(country, 0.0);
    }

    /**
     * Determine severity level based on threat score and analysis
     */
    private ThreatLocation.SeverityLevel determineSeverityLevel(double threatScore, ThreatAnalysis analysis) {
        if (threatScore >= 9.0 || analysis.getIsMalware() || analysis.getIsBotnet()) {
            return ThreatLocation.SeverityLevel.CRITICAL;
        } else if (threatScore >= 7.0 || analysis.getIsTor()) {
            return ThreatLocation.SeverityLevel.HIGH;
        } else if (threatScore >= 4.0 || analysis.getIsProxy()) {
            return ThreatLocation.SeverityLevel.MEDIUM;
        } else {
            return ThreatLocation.SeverityLevel.LOW;
        }
    }

    /**
     * Determine if an IP should be blocked based on threat analysis
     */
    private boolean shouldBlockIp(ThreatAnalysis analysis) {
        if (!autoBlockEnabled) {
            return false;
        }

        // Block if threat score exceeds threshold
        if (analysis.getThreatScore() >= autoBlockThresholdScore) {
            return true;
        }

        // Block if recent threat count exceeds threshold
        if (analysis.getRecentThreatCount() >= threatCountThreshold) {
            return true;
        }

        // Block known malware/botnet sources immediately
        if (analysis.getIsMalware() || analysis.getIsBotnet()) {
            return true;
        }

        // Block if critical severity regardless of score
        if (analysis.getSeverityLevel() == ThreatLocation.SeverityLevel.CRITICAL) {
            return true;
        }

        return false;
    }

    /**
     * Create a threat block entry
     */
    @Transactional
    private ThreatBlock createThreatBlock(String ipAddress, ThreatAnalysis analysis) {
        ThreatBlock block = new ThreatBlock();
        block.setBlockUuid(ThreatBlock.generateBlockUuid());
        block.setBlockedIp(ipAddress);
        block.setCountry(analysis.getCountry());
        block.setRegion(analysis.getRegion());
        block.setCity(analysis.getCity());
        block.setBlockType(ThreatBlock.BlockType.IP_ADDRESS);
        block.setSeverityLevel(analysis.getSeverityLevel());
        block.setThreatScore(analysis.getThreatScore());
        block.setThreatCount(analysis.getRecentThreatCount());
        block.setAutoBlocked(true);
        block.setFirstBlocked(LocalDateTime.now());
        block.setLastSeen(LocalDateTime.now());

        // Set security flags
        block.setIsVpn(analysis.getIsVpn());
        block.setIsProxy(analysis.getIsProxy());
        block.setIsTor(analysis.getIsTor());
        block.setIsMalware(analysis.getIsMalware());
        block.setIsBotnet(analysis.getIsBotnet());

        // Determine block reason and duration
        determineBlockReasonAndDuration(block, analysis);

        // Save the block
        block = threatBlockRepository.save(block);

        // Log the blocking action
        logBlockingAction(block, analysis);

        // Send notification
        sendBlockNotification(block);

        return block;
    }

    /**
     * Determine block reason and duration based on threat analysis
     */
    private void determineBlockReasonAndDuration(ThreatBlock block, ThreatAnalysis analysis) {
        // Determine block reason
        if (analysis.getIsMalware()) {
            block.setBlockReason(ThreatBlock.BlockReason.MALICIOUS_ACTIVITY);
            block.setIsPermanent(true);
        } else if (analysis.getIsBotnet()) {
            block.setBlockReason(ThreatBlock.BlockReason.MALICIOUS_ACTIVITY);
            block.setBlockDurationMinutes(1440); // 24 hours
        } else if (analysis.getThreatScore() >= permanentBlockThresholdScore) {
            block.setBlockReason(ThreatBlock.BlockReason.AUTOMATED_DETECTION);
            block.setIsPermanent(true);
        } else if (analysis.getRecentThreatCount() >= threatCountThreshold) {
            block.setBlockReason(ThreatBlock.BlockReason.SUSPICIOUS_BEHAVIOR);
            block.setBlockDurationMinutes(defaultBlockDurationMinutes * 2);
        } else if (analysis.getIsTor()) {
            block.setBlockReason(ThreatBlock.BlockReason.SUSPICIOUS_BEHAVIOR);
            block.setBlockDurationMinutes(defaultBlockDurationMinutes);
        } else {
            block.setBlockReason(ThreatBlock.BlockReason.AUTOMATED_DETECTION);
            block.setBlockDurationMinutes(defaultBlockDurationMinutes);
        }

        // Set expiration if not permanent
        if (!block.getIsPermanent()) {
            block.setExpirationFromDuration();
        }
    }

    /**
     * Check if an IP address is whitelisted
     */
    private boolean isWhitelisted(String ipAddress) {
        // Check database whitelist
        Optional<ThreatBlock> whitelist = threatBlockRepository.findWhitelistedByIp(ipAddress);
        if (whitelist.isPresent()) {
            return true;
        }

        // Check hardcoded whitelist ranges
        for (String range : whitelistedRanges) {
            if (isIpInRange(ipAddress, range)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if IP is in a given CIDR range (simplified implementation)
     */
    private boolean isIpInRange(String ipAddress, String cidrRange) {
        // This is a simplified implementation - in production, use proper CIDR libraries
        if (cidrRange.contains("/")) {
            String[] parts = cidrRange.split("/");
            String networkIp = parts[0];
            return ipAddress.startsWith(networkIp.substring(0, networkIp.lastIndexOf('.') + 1));
        }
        return false;
    }

    /**
     * Manually block an IP address
     */
    @Transactional
    public ThreatBlock manuallyBlockIp(String ipAddress, ThreatBlock.BlockReason reason, 
                                      Integer durationMinutes, String blockedByUser) {
        
        ThreatAnalysis analysis = analyzeThreatLevel(ipAddress);
        
        ThreatBlock block = new ThreatBlock();
        block.setBlockUuid(ThreatBlock.generateBlockUuid());
        block.setBlockedIp(ipAddress);
        block.setCountry(analysis.getCountry());
        block.setRegion(analysis.getRegion());
        block.setCity(analysis.getCity());
        block.setBlockType(ThreatBlock.BlockType.IP_ADDRESS);
        block.setBlockReason(reason);
        block.setSeverityLevel(analysis.getSeverityLevel());
        block.setThreatScore(analysis.getThreatScore());
        block.setAutoBlocked(false);
        block.setBlockedByUser(blockedByUser);
        block.setFirstBlocked(LocalDateTime.now());
        block.setLastSeen(LocalDateTime.now());

        if (durationMinutes != null && durationMinutes > 0) {
            block.setBlockDurationMinutes(durationMinutes);
            block.setExpirationFromDuration();
        } else {
            block.setIsPermanent(true);
        }

        block = threatBlockRepository.save(block);
        
        logBlockingAction(block, analysis);
        sendBlockNotification(block);
        
        return block;
    }

    /**
     * Unblock an IP address
     */
    @Transactional
    public void unblockIp(String ipAddress, String unblockedByUser, String reason) {
        Optional<ThreatBlock> blockOpt = threatBlockRepository.findActiveBlockByIp(ipAddress);
        if (blockOpt.isPresent()) {
            ThreatBlock block = blockOpt.get();
            block.setIsActive(false);
            block.setBlockStatus(ThreatBlock.BlockStatus.DISABLED);
            block.setReviewedByUser(unblockedByUser);
            block.setReviewNotes(reason);
            threatBlockRepository.save(block);

            log.info("IP {} unblocked by {} - Reason: {}", ipAddress, unblockedByUser, reason);
            
            // Send unblock notification
            sendUnblockNotification(block, unblockedByUser, reason);
        }
    }

    /**
     * Log blocking action
     */
    private void logBlockingAction(ThreatBlock block, ThreatAnalysis analysis) {
        try {
            GeoThreatLog logEntry = new GeoThreatLog();
            logEntry.setThreatId("BLOCK-" + block.getBlockUuid());
            logEntry.setSourceIp(block.getBlockedIp());
            logEntry.setCountry(block.getCountry());
            logEntry.setRegion(block.getRegion());
            logEntry.setCity(block.getCity());
            logEntry.setThreatType(ThreatLocation.ThreatType.UNKNOWN);
            logEntry.setSeverity(block.getSeverityLevel());
            logEntry.setRiskScore(block.getThreatScore());
            logEntry.setIsVpn(block.getIsVpn());
            logEntry.setIsProxy(block.getIsProxy());
            logEntry.setIsTor(block.getIsTor());
            logEntry.setIsMalware(block.getIsMalware());
            logEntry.setIsBotnet(block.getIsBotnet());
            logEntry.setResponseAction(GeoThreatLog.ResponseAction.BLOCK);
            logEntry.setBlocked(true);
            logEntry.setNotes("IP blocked: " + block.getBlockReason());

            geoThreatLogRepository.save(logEntry);
            
            log.info("Threat blocking action logged: {}", block.getBlockSummary());
            
        } catch (Exception e) {
            log.error("Error logging blocking action for IP: {}", block.getBlockedIp(), e);
        }
    }

    /**
     * Send block notification via Kafka
     */
    @Async
    private void sendBlockNotification(ThreatBlock block) {
        try {
            Map<String, Object> notification = Map.of(
                "type", "THREAT_BLOCKED",
                "ipAddress", block.getBlockedIp(),
                "location", block.getFormattedLocation(),
                "reason", block.getBlockReason().toString(),
                "severity", block.getSeverityLevel().toString(),
                "threatScore", block.getThreatScore(),
                "timestamp", LocalDateTime.now().toString(),
                "blockId", block.getBlockUuid()
            );

            kafkaTemplate.send("threat-alerts", notification);
            
        } catch (Exception e) {
            log.error("Error sending block notification for IP: {}", block.getBlockedIp(), e);
        }
    }

    /**
     * Send unblock notification via Kafka
     */
    @Async
    private void sendUnblockNotification(ThreatBlock block, String unblockedBy, String reason) {
        try {
            Map<String, Object> notification = Map.of(
                "type", "THREAT_UNBLOCKED",
                "ipAddress", block.getBlockedIp(),
                "location", block.getFormattedLocation(),
                "unblockedBy", unblockedBy,
                "reason", reason,
                "timestamp", LocalDateTime.now().toString(),
                "blockId", block.getBlockUuid()
            );

            kafkaTemplate.send("threat-alerts", notification);
            
        } catch (Exception e) {
            log.error("Error sending unblock notification for IP: {}", block.getBlockedIp(), e);
        }
    }

    /**
     * Scheduled task to clean up expired blocks
     */
    @Scheduled(fixedRate = 300000) // Every 5 minutes
    @Transactional
    public void cleanupExpiredBlocks() {
        try {
            List<ThreatBlock> expiredBlocks = threatBlockRepository.findExpiredBlocks(LocalDateTime.now());
            
            for (ThreatBlock block : expiredBlocks) {
                if (block.isExpired()) {
                    block.setIsActive(false);
                    block.setBlockStatus(ThreatBlock.BlockStatus.EXPIRED);
                    threatBlockRepository.save(block);
                    
                    log.info("Expired block removed for IP: {}", block.getBlockedIp());
                }
            }
            
            if (!expiredBlocks.isEmpty()) {
                log.info("Cleaned up {} expired threat blocks", expiredBlocks.size());
            }
            
        } catch (Exception e) {
            log.error("Error during expired blocks cleanup", e);
        }
    }

    /**
     * Get current block status for an IP
     */
    public Optional<ThreatBlock> getBlockStatus(String ipAddress) {
        return threatBlockRepository.findActiveBlockByIp(ipAddress)
            .filter(ThreatBlock::isCurrentlyBlocked);
    }

    /**
     * Block Decision class
     */
    public static class BlockDecision {
        private final boolean shouldBlock;
        private final String reason;
        private final long remainingTimeMinutes;
        private final ThreatBlock block;

        public BlockDecision(boolean shouldBlock, String reason, long remainingTimeMinutes, ThreatBlock block) {
            this.shouldBlock = shouldBlock;
            this.reason = reason;
            this.remainingTimeMinutes = remainingTimeMinutes;
            this.block = block;
        }

        // Getters
        public boolean shouldBlock() { return shouldBlock; }
        public String getReason() { return reason; }
        public long getRemainingTimeMinutes() { return remainingTimeMinutes; }
        public ThreatBlock getBlock() { return block; }
    }

    /**
     * Threat Analysis class
     */
    public static class ThreatAnalysis {
        private String ipAddress;
        private String country;
        private String region;
        private String city;
        private Double latitude;
        private Double longitude;
        private Boolean isVpn = false;
        private Boolean isProxy = false;
        private Boolean isTor = false;
        private Boolean isMalware = false;
        private Boolean isBotnet = false;
        private int recentThreatCount = 0;
        private int previousThreats = 0;
        private double threatScore = 0.0;
        private ThreatLocation.SeverityLevel severityLevel = ThreatLocation.SeverityLevel.LOW;

        // Getters and setters
        public String getIpAddress() { return ipAddress; }
        public void setIpAddress(String ipAddress) { this.ipAddress = ipAddress; }
        
        public String getCountry() { return country; }
        public void setCountry(String country) { this.country = country; }
        
        public String getRegion() { return region; }
        public void setRegion(String region) { this.region = region; }
        
        public String getCity() { return city; }
        public void setCity(String city) { this.city = city; }
        
        public Double getLatitude() { return latitude; }
        public void setLatitude(Double latitude) { this.latitude = latitude; }
        
        public Double getLongitude() { return longitude; }
        public void setLongitude(Double longitude) { this.longitude = longitude; }
        
        public Boolean getIsVpn() { return isVpn; }
        public void setIsVpn(Boolean isVpn) { this.isVpn = isVpn; }
        
        public Boolean getIsProxy() { return isProxy; }
        public void setIsProxy(Boolean isProxy) { this.isProxy = isProxy; }
        
        public Boolean getIsTor() { return isTor; }
        public void setIsTor(Boolean isTor) { this.isTor = isTor; }
        
        public Boolean getIsMalware() { return isMalware; }
        public void setIsMalware(Boolean isMalware) { this.isMalware = isMalware; }
        
        public Boolean getIsBotnet() { return isBotnet; }
        public void setIsBotnet(Boolean isBotnet) { this.isBotnet = isBotnet; }
        
        public int getRecentThreatCount() { return recentThreatCount; }
        public void setRecentThreatCount(int recentThreatCount) { this.recentThreatCount = recentThreatCount; }
        
        public int getPreviousThreats() { return previousThreats; }
        public void setPreviousThreats(int previousThreats) { this.previousThreats = previousThreats; }
        
        public double getThreatScore() { return threatScore; }
        public void setThreatScore(double threatScore) { this.threatScore = threatScore; }
        
        public ThreatLocation.SeverityLevel getSeverityLevel() { return severityLevel; }
        public void setSeverityLevel(ThreatLocation.SeverityLevel severityLevel) { this.severityLevel = severityLevel; }
    }
}