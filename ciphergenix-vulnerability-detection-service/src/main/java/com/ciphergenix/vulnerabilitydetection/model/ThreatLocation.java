package com.ciphergenix.vulnerabilitydetection.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Geographic Threat Location Entity for CipherGenix AI Security Platform
 * 
 * Tracks the geographic origin of security threats and vulnerabilities
 * for enhanced situational awareness and threat intelligence.
 */
@Entity
@Table(name = "threat_locations")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ThreatLocation {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "location_id")
    private Long locationId;

    @Column(name = "threat_id", nullable = false)
    private String threatId;

    @Column(name = "ip_address", nullable = false, length = 45)
    private String ipAddress;

    @Column(name = "country", length = 100)
    private String country;

    @Column(name = "country_code", length = 3)
    private String countryCode;

    @Column(name = "region", length = 100)
    private String region;

    @Column(name = "region_code", length = 10)
    private String regionCode;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "postal_code", length = 20)
    private String postalCode;

    @Column(name = "latitude", precision = 10, scale = 8)
    private Double latitude;

    @Column(name = "longitude", precision = 11, scale = 8)
    private Double longitude;

    @Column(name = "timezone", length = 50)
    private String timezone;

    @Column(name = "isp", length = 200)
    private String isp;

    @Column(name = "organization", length = 200)
    private String organization;

    @Column(name = "threat_type")
    @Enumerated(EnumType.STRING)
    private ThreatType threatType;

    @Column(name = "severity_level")
    @Enumerated(EnumType.STRING)
    private SeverityLevel severityLevel;

    @Column(name = "threat_count", nullable = false)
    private Integer threatCount = 1;

    @Column(name = "is_vpn", nullable = false)
    private Boolean isVpn = false;

    @Column(name = "is_proxy", nullable = false)
    private Boolean isProxy = false;

    @Column(name = "is_tor", nullable = false)
    private Boolean isTor = false;

    @Column(name = "is_hosting", nullable = false)
    private Boolean isHosting = false;

    @Column(name = "confidence_score", precision = 5, scale = 2)
    private Double confidenceScore;

    @Column(name = "first_seen")
    private LocalDateTime firstSeen;

    @Column(name = "last_seen")
    private LocalDateTime lastSeen;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata;

    // Enumeration for Threat Types
    public enum ThreatType {
        DATA_POISONING,
        ADVERSARIAL_ATTACK,
        MODEL_THEFT,
        INJECTION_ATTACK,
        EVASION_ATTACK,
        MEMBERSHIP_INFERENCE,
        MODEL_INVERSION,
        BACKDOOR_ATTACK,
        EXTRACTION_ATTACK,
        UNKNOWN
    }

    // Enumeration for Severity Levels
    public enum SeverityLevel {
        LOW,
        MEDIUM,
        HIGH,
        CRITICAL
    }

    /**
     * Get formatted location string
     */
    public String getFormattedLocation() {
        StringBuilder location = new StringBuilder();
        if (city != null && !city.isEmpty()) {
            location.append(city);
        }
        if (region != null && !region.isEmpty()) {
            if (location.length() > 0) location.append(", ");
            location.append(region);
        }
        if (country != null && !country.isEmpty()) {
            if (location.length() > 0) location.append(", ");
            location.append(country);
        }
        return location.toString();
    }

    /**
     * Check if location is suspicious based on VPN/Proxy/Tor usage
     */
    public boolean isSuspiciousLocation() {
        return isVpn || isProxy || isTor;
    }

    /**
     * Get risk score based on threat characteristics
     */
    public double getRiskScore() {
        double baseScore = switch (severityLevel) {
            case LOW -> 2.5;
            case MEDIUM -> 5.0;
            case HIGH -> 7.5;
            case CRITICAL -> 10.0;
        };

        // Adjust for suspicious characteristics
        if (isVpn) baseScore += 1.0;
        if (isProxy) baseScore += 1.5;
        if (isTor) baseScore += 2.0;
        if (threatCount > 5) baseScore += 1.0;

        // Apply confidence score
        if (confidenceScore != null) {
            baseScore *= (confidenceScore / 100.0);
        }

        return Math.min(baseScore, 10.0);
    }
}