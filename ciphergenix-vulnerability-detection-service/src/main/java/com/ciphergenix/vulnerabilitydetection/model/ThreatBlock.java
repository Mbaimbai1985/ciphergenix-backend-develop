package com.ciphergenix.vulnerabilitydetection.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

/**
 * Threat Block Entity for CipherGenix AI Security Platform
 * 
 * Manages blocked IPs, domains, and networks with automatic threat response
 * and mitigation capabilities for real-time security protection.
 */
@Entity
@Table(name = "threat_blocks", indexes = {
    @Index(name = "idx_threat_block_ip", columnList = "blocked_ip"),
    @Index(name = "idx_threat_block_status", columnList = "block_status"),
    @Index(name = "idx_threat_block_type", columnList = "block_type"),
    @Index(name = "idx_threat_block_expiry", columnList = "expires_at"),
    @Index(name = "idx_threat_block_created", columnList = "created_at"),
    @Index(name = "idx_threat_block_active", columnList = "is_active")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ThreatBlock {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "block_id")
    private Long blockId;

    @Column(name = "block_uuid", nullable = false, unique = true, length = 40)
    private String blockUuid;

    @Column(name = "blocked_ip", nullable = false, length = 45)
    private String blockedIp;

    @Column(name = "ip_range", length = 50)
    private String ipRange; // CIDR notation for network blocks

    @Column(name = "domain", length = 255)
    private String domain;

    @Column(name = "country", length = 100)
    private String country;

    @Column(name = "country_code", length = 3)
    private String countryCode;

    @Column(name = "region", length = 100)
    private String region;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "block_type", nullable = false)
    @Enumerated(EnumType.STRING)
    private BlockType blockType;

    @Column(name = "block_reason", nullable = false)
    @Enumerated(EnumType.STRING)
    private BlockReason blockReason;

    @Column(name = "block_status", nullable = false)
    @Enumerated(EnumType.STRING)
    private BlockStatus blockStatus = BlockStatus.ACTIVE;

    @Column(name = "severity_level", nullable = false)
    @Enumerated(EnumType.STRING)
    private ThreatLocation.SeverityLevel severityLevel;

    @Column(name = "threat_score", precision = 5, scale = 2)
    private Double threatScore;

    @Column(name = "confidence_score", precision = 5, scale = 2)
    private Double confidenceScore;

    @Column(name = "threat_count", nullable = false)
    private Integer threatCount = 1;

    @Column(name = "block_duration_minutes")
    private Integer blockDurationMinutes;

    @Column(name = "is_permanent", nullable = false)
    private Boolean isPermanent = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "is_whitelisted", nullable = false)
    private Boolean isWhitelisted = false;

    @Column(name = "auto_blocked", nullable = false)
    private Boolean autoBlocked = false;

    @Column(name = "manual_review_required", nullable = false)
    private Boolean manualReviewRequired = false;

    // Time Management
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "expires_at")
    private LocalDateTime expiresAt;

    @Column(name = "last_seen")
    private LocalDateTime lastSeen;

    @Column(name = "first_blocked")
    private LocalDateTime firstBlocked;

    // Detection and Response Information
    @Column(name = "detection_algorithm", length = 100)
    private String detectionAlgorithm;

    @Column(name = "trigger_event_id", length = 100)
    private String triggerEventId;

    @Column(name = "related_threat_ids", columnDefinition = "TEXT")
    private String relatedThreatIds;

    @Column(name = "blocked_attempts", nullable = false)
    private Long blockedAttempts = 0L;

    @Column(name = "bypass_attempts", nullable = false)
    private Long bypassAttempts = 0L;

    // Administrative Information
    @Column(name = "blocked_by_user", length = 100)
    private String blockedByUser;

    @Column(name = "reviewed_by_user", length = 100)
    private String reviewedByUser;

    @Column(name = "review_notes", columnDefinition = "TEXT")
    private String reviewNotes;

    @Column(name = "escalation_level")
    private Integer escalationLevel = 0;

    @Column(name = "alert_sent", nullable = false)
    private Boolean alertSent = false;

    @Column(name = "incident_ticket", length = 100)
    private String incidentTicket;

    // Network Information
    @Column(name = "isp", length = 200)
    private String isp;

    @Column(name = "organization", length = 200)
    private String organization;

    @Column(name = "as_number")
    private Long asNumber;

    @Column(name = "as_name", length = 200)
    private String asName;

    // Security Context
    @Column(name = "is_vpn", nullable = false)
    private Boolean isVpn = false;

    @Column(name = "is_proxy", nullable = false)
    private Boolean isProxy = false;

    @Column(name = "is_tor", nullable = false)
    private Boolean isTor = false;

    @Column(name = "is_malware", nullable = false)
    private Boolean isMalware = false;

    @Column(name = "is_botnet", nullable = false)
    private Boolean isBotnet = false;

    @Column(name = "reputation_sources", columnDefinition = "TEXT")
    private String reputationSources;

    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata;

    @Column(name = "raw_detection_data", columnDefinition = "TEXT")
    private String rawDetectionData;

    // Block Type Enumeration
    public enum BlockType {
        IP_ADDRESS,
        IP_RANGE,
        DOMAIN,
        COUNTRY,
        REGION,
        ASN,
        USER_AGENT,
        CUSTOM_RULE
    }

    // Block Reason Enumeration
    public enum BlockReason {
        MALICIOUS_ACTIVITY,
        DATA_POISONING_ATTEMPT,
        ADVERSARIAL_ATTACK,
        MODEL_THEFT_ATTEMPT,
        BRUTE_FORCE_ATTACK,
        DDoS_ATTACK,
        SUSPICIOUS_BEHAVIOR,
        REPUTATION_BLACKLIST,
        GEOGRAPHIC_RESTRICTION,
        COMPLIANCE_VIOLATION,
        MANUAL_BLOCK,
        AUTOMATED_DETECTION,
        THREAT_INTELLIGENCE,
        ANOMALY_DETECTION,
        RATE_LIMIT_EXCEEDED
    }

    // Block Status Enumeration
    public enum BlockStatus {
        ACTIVE,
        EXPIRED,
        DISABLED,
        PENDING_REVIEW,
        WHITELISTED,
        ESCALATED,
        TEMPORARY,
        PERMANENT
    }

    /**
     * Check if the block is currently active and valid
     */
    public boolean isCurrentlyBlocked() {
        if (!isActive || blockStatus != BlockStatus.ACTIVE) {
            return false;
        }
        
        if (isWhitelisted) {
            return false;
        }
        
        if (!isPermanent && expiresAt != null) {
            return LocalDateTime.now().isBefore(expiresAt);
        }
        
        return true;
    }

    /**
     * Check if the block has expired
     */
    public boolean isExpired() {
        if (isPermanent) {
            return false;
        }
        
        return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);
    }

    /**
     * Calculate remaining block time in minutes
     */
    public long getRemainingBlockTimeMinutes() {
        if (isPermanent || expiresAt == null) {
            return -1; // Permanent block
        }
        
        LocalDateTime now = LocalDateTime.now();
        if (now.isAfter(expiresAt)) {
            return 0; // Expired
        }
        
        return java.time.temporal.ChronoUnit.MINUTES.between(now, expiresAt);
    }

    /**
     * Get risk assessment score
     */
    public double getRiskAssessment() {
        double risk = 0.0;
        
        // Base risk from threat score
        if (threatScore != null) {
            risk += threatScore * 10;
        }
        
        // Risk from severity
        risk += switch (severityLevel) {
            case LOW -> 10;
            case MEDIUM -> 25;
            case HIGH -> 50;
            case CRITICAL -> 100;
        };
        
        // Risk from threat characteristics
        if (isMalware) risk += 30;
        if (isBotnet) risk += 25;
        if (isTor) risk += 15;
        if (isProxy) risk += 10;
        if (isVpn) risk += 5;
        
        // Risk from frequency
        if (threatCount > 100) risk += 20;
        else if (threatCount > 50) risk += 15;
        else if (threatCount > 10) risk += 10;
        else if (threatCount > 5) risk += 5;
        
        return Math.min(risk, 100.0);
    }

    /**
     * Get formatted location string
     */
    public String getFormattedLocation() {
        StringBuilder location = new StringBuilder();
        if (city != null && !city.isEmpty()) {
            location.append(city);
        }
        if (region != null && !region.isEmpty()) {
            if (location.length() > 0) location.append(", ");
            location.append(region);
        }
        if (country != null && !country.isEmpty()) {
            if (location.length() > 0) location.append(", ");
            location.append(country);
        }
        return location.toString();
    }

    /**
     * Get block summary for logging and notifications
     */
    public String getBlockSummary() {
        return String.format("[BLOCKED] %s (%s) - Reason: %s, Severity: %s, Score: %.2f",
            blockedIp,
            getFormattedLocation(),
            blockReason,
            severityLevel,
            threatScore != null ? threatScore : 0.0
        );
    }

    /**
     * Check if block requires escalation
     */
    public boolean requiresEscalation() {
        return severityLevel == ThreatLocation.SeverityLevel.CRITICAL ||
               (threatScore != null && threatScore >= 9.0) ||
               threatCount > 100 ||
               (isMalware && !alertSent) ||
               (isBotnet && escalationLevel == 0);
    }

    /**
     * Generate unique block identifier
     */
    public static String generateBlockUuid() {
        return java.util.UUID.randomUUID().toString();
    }

    /**
     * Set expiration time based on duration
     */
    public void setExpirationFromDuration() {
        if (blockDurationMinutes != null && blockDurationMinutes > 0 && !isPermanent) {
            this.expiresAt = LocalDateTime.now().plusMinutes(blockDurationMinutes);
        }
    }

    /**
     * Extend block duration
     */
    public void extendBlock(int additionalMinutes) {
        if (!isPermanent && expiresAt != null) {
            this.expiresAt = expiresAt.plusMinutes(additionalMinutes);
            this.blockDurationMinutes = (blockDurationMinutes != null ? blockDurationMinutes : 0) + additionalMinutes;
        }
    }

    /**
     * Convert to permanent block
     */
    public void makePermanent(String reason) {
        this.isPermanent = true;
        this.expiresAt = null;
        this.blockDurationMinutes = null;
        this.blockStatus = BlockStatus.PERMANENT;
        this.reviewNotes = (reviewNotes != null ? reviewNotes + "; " : "") + 
                          "Made permanent: " + reason + " at " + LocalDateTime.now();
    }
}