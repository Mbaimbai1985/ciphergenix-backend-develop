package com.ciphergenix.vulnerabilitydetection.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Threat Matrix Entity for CipherGenix AI Security Platform
 * 
 * Aggregates and tracks threat quantities by geographic location,
 * providing comprehensive analytics and metrics for threat intelligence.
 */
@Entity
@Table(name = "threat_matrix")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ThreatMatrix {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "matrix_id")
    private Long matrixId;

    @Column(name = "location_key", nullable = false, unique = true, length = 200)
    private String locationKey; // Format: "country|region|city"

    @Column(name = "country", nullable = false, length = 100)
    private String country;

    @Column(name = "country_code", length = 3)
    private String countryCode;

    @Column(name = "region", length = 100)
    private String region;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "latitude", precision = 10, scale = 8)
    private Double latitude;

    @Column(name = "longitude", precision = 11, scale = 8)
    private Double longitude;

    // Threat Quantity Metrics
    @Column(name = "total_threats", nullable = false)
    private Long totalThreats = 0L;

    @Column(name = "unique_ips", nullable = false)
    private Long uniqueIps = 0L;

    @Column(name = "data_poisoning_count", nullable = false)
    private Long dataPoisoningCount = 0L;

    @Column(name = "adversarial_attack_count", nullable = false)
    private Long adversarialAttackCount = 0L;

    @Column(name = "model_theft_count", nullable = false)
    private Long modelTheftCount = 0L;

    @Column(name = "injection_attack_count", nullable = false)
    private Long injectionAttackCount = 0L;

    @Column(name = "evasion_attack_count", nullable = false)
    private Long evasionAttackCount = 0L;

    @Column(name = "membership_inference_count", nullable = false)
    private Long membershipInferenceCount = 0L;

    @Column(name = "model_inversion_count", nullable = false)
    private Long modelInversionCount = 0L;

    @Column(name = "backdoor_attack_count", nullable = false)
    private Long backdoorAttackCount = 0L;

    @Column(name = "extraction_attack_count", nullable = false)
    private Long extractionAttackCount = 0L;

    @Column(name = "unknown_threat_count", nullable = false)
    private Long unknownThreatCount = 0L;

    // Severity Distribution
    @Column(name = "low_severity_count", nullable = false)
    private Long lowSeverityCount = 0L;

    @Column(name = "medium_severity_count", nullable = false)
    private Long mediumSeverityCount = 0L;

    @Column(name = "high_severity_count", nullable = false)
    private Long highSeverityCount = 0L;

    @Column(name = "critical_severity_count", nullable = false)
    private Long criticalSeverityCount = 0L;

    // Risk and Confidence Metrics
    @Column(name = "average_risk_score", precision = 5, scale = 2)
    private Double averageRiskScore = 0.0;

    @Column(name = "max_risk_score", precision = 5, scale = 2)
    private Double maxRiskScore = 0.0;

    @Column(name = "average_confidence", precision = 5, scale = 2)
    private Double averageConfidence = 0.0;

    // Suspicious Activity Metrics
    @Column(name = "vpn_threats", nullable = false)
    private Long vpnThreats = 0L;

    @Column(name = "proxy_threats", nullable = false)
    private Long proxyThreats = 0L;

    @Column(name = "tor_threats", nullable = false)
    private Long torThreats = 0L;

    @Column(name = "hosting_threats", nullable = false)
    private Long hostingThreats = 0L;

    // Time-based Analytics
    @Column(name = "first_threat_seen")
    private LocalDateTime firstThreatSeen;

    @Column(name = "last_threat_seen")
    private LocalDateTime lastThreatSeen;

    @Column(name = "threats_last_24h", nullable = false)
    private Long threatsLast24h = 0L;

    @Column(name = "threats_last_7d", nullable = false)
    private Long threatsLast7d = 0L;

    @Column(name = "threats_last_30d", nullable = false)
    private Long threatsLast30d = 0L;

    // Ranking and Classification
    @Column(name = "threat_rank", nullable = false)
    private Integer threatRank = 0;

    @Column(name = "risk_classification")
    @Enumerated(EnumType.STRING)
    private RiskClassification riskClassification = RiskClassification.LOW;

    @Column(name = "is_blacklisted", nullable = false)
    private Boolean isBlacklisted = false;

    @Column(name = "is_whitelisted", nullable = false)
    private Boolean isWhitelisted = false;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "last_calculated")
    private LocalDateTime lastCalculated;

    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata;

    // Risk Classification Enum
    public enum RiskClassification {
        VERY_LOW,
        LOW,
        MEDIUM,
        HIGH,
        VERY_HIGH,
        CRITICAL
    }

    /**
     * Calculate threat density (threats per unique IP)
     */
    public double getThreatDensity() {
        if (uniqueIps == 0) return 0.0;
        return (double) totalThreats / uniqueIps;
    }

    /**
     * Calculate critical threat percentage
     */
    public double getCriticalThreatPercentage() {
        if (totalThreats == 0) return 0.0;
        return ((double) criticalSeverityCount / totalThreats) * 100.0;
    }

    /**
     * Calculate suspicious activity percentage
     */
    public double getSuspiciousActivityPercentage() {
        if (totalThreats == 0) return 0.0;
        long suspiciousThreats = vpnThreats + proxyThreats + torThreats;
        return ((double) suspiciousThreats / totalThreats) * 100.0;
    }

    /**
     * Get threat velocity (threats per day average)
     */
    public double getThreatVelocity() {
        if (firstThreatSeen == null || lastThreatSeen == null) return 0.0;
        
        long daysBetween = java.time.temporal.ChronoUnit.DAYS.between(
            firstThreatSeen.toLocalDate(), 
            lastThreatSeen.toLocalDate()
        );
        
        if (daysBetween == 0) daysBetween = 1;
        return (double) totalThreats / daysBetween;
    }

    /**
     * Get primary threat type
     */
    public String getPrimaryThreatType() {
        Long maxCount = Math.max(dataPoisoningCount,
            Math.max(adversarialAttackCount,
                Math.max(modelTheftCount,
                    Math.max(injectionAttackCount,
                        Math.max(evasionAttackCount,
                            Math.max(membershipInferenceCount,
                                Math.max(modelInversionCount,
                                    Math.max(backdoorAttackCount,
                                        Math.max(extractionAttackCount, unknownThreatCount)))))))));

        if (maxCount.equals(dataPoisoningCount)) return "DATA_POISONING";
        if (maxCount.equals(adversarialAttackCount)) return "ADVERSARIAL_ATTACK";
        if (maxCount.equals(modelTheftCount)) return "MODEL_THEFT";
        if (maxCount.equals(injectionAttackCount)) return "INJECTION_ATTACK";
        if (maxCount.equals(evasionAttackCount)) return "EVASION_ATTACK";
        if (maxCount.equals(membershipInferenceCount)) return "MEMBERSHIP_INFERENCE";
        if (maxCount.equals(modelInversionCount)) return "MODEL_INVERSION";
        if (maxCount.equals(backdoorAttackCount)) return "BACKDOOR_ATTACK";
        if (maxCount.equals(extractionAttackCount)) return "EXTRACTION_ATTACK";
        return "UNKNOWN";
    }

    /**
     * Get formatted location display
     */
    public String getLocationDisplay() {
        StringBuilder display = new StringBuilder();
        if (city != null && !city.isEmpty()) {
            display.append(city);
        }
        if (region != null && !region.isEmpty()) {
            if (display.length() > 0) display.append(", ");
            display.append(region);
        }
        if (country != null && !country.isEmpty()) {
            if (display.length() > 0) display.append(", ");
            display.append(country);
        }
        return display.toString();
    }

    /**
     * Update risk classification based on current metrics
     */
    public void updateRiskClassification() {
        double riskScore = 0.0;

        // Base risk from threat count
        if (totalThreats > 1000) riskScore += 30;
        else if (totalThreats > 500) riskScore += 20;
        else if (totalThreats > 100) riskScore += 10;
        else if (totalThreats > 10) riskScore += 5;

        // Risk from severity distribution
        riskScore += (criticalSeverityCount * 4);
        riskScore += (highSeverityCount * 2);
        riskScore += (mediumSeverityCount * 1);

        // Risk from suspicious activity
        riskScore += getSuspiciousActivityPercentage() * 0.3;

        // Risk from recent activity
        if (threatsLast24h > 10) riskScore += 10;
        else if (threatsLast24h > 5) riskScore += 5;

        // Classify based on total score
        if (riskScore >= 100) this.riskClassification = RiskClassification.CRITICAL;
        else if (riskScore >= 75) this.riskClassification = RiskClassification.VERY_HIGH;
        else if (riskScore >= 50) this.riskClassification = RiskClassification.HIGH;
        else if (riskScore >= 25) this.riskClassification = RiskClassification.MEDIUM;
        else if (riskScore >= 10) this.riskClassification = RiskClassification.LOW;
        else this.riskClassification = RiskClassification.VERY_LOW;
    }

    /**
     * Generate location key for aggregation
     */
    public static String generateLocationKey(String country, String region, String city) {
        StringBuilder key = new StringBuilder();
        key.append(country != null ? country : "Unknown");
        key.append("|");
        key.append(region != null ? region : "Unknown");
        key.append("|");
        key.append(city != null ? city : "Unknown");
        return key.toString();
    }
}