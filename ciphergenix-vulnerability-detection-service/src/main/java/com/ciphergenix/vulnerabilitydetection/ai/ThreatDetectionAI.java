package com.ciphergenix.vulnerabilitydetection.ai;

import com.ciphergenix.vulnerabilitydetection.model.GeoThreatLog;
import com.ciphergenix.vulnerabilitydetection.model.ThreatLocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;

/**
 * AI-Powered Threat Detection System for CipherGenix Security Platform
 * 
 * Implements advanced machine learning algorithms including:
 * - Deep Neural Networks for threat classification
 * - Isolation Forest for anomaly detection
 * - LSTM networks for sequential pattern recognition
 * - Ensemble methods for improved accuracy
 * - Real-time adaptive learning capabilities
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class ThreatDetectionAI {

    @Value("${ciphergenix.ai.threat-detection.enabled:true}")
    private boolean aiDetectionEnabled;

    @Value("${ciphergenix.ai.threat-detection.confidence-threshold:0.85}")
    private double confidenceThreshold;

    @Value("${ciphergenix.ai.threat-detection.anomaly-threshold:0.75}")
    private double anomalyThreshold;

    @Value("${ciphergenix.ai.threat-detection.learning-rate:0.001}")
    private double learningRate;

    // AI Model Components
    private final DeepNeuralNetwork threatClassificationNetwork;
    private final IsolationForestAnomalyDetector anomalyDetector;
    private final LSTMSequenceAnalyzer sequenceAnalyzer;
    private final EnsemblePredictor ensemblePredictor;
    private final AdaptiveLearningEngine learningEngine;

    /**
     * AI-powered threat detection and classification
     */
    public AiThreatDetectionResult detectThreat(ThreatDetectionInput input) {
        if (!aiDetectionEnabled) {
            return createFallbackResult(input);
        }

        try {
            log.debug("Starting AI threat detection for IP: {}", input.getIpAddress());

            // Step 1: Feature extraction and preprocessing
            double[] features = extractFeatures(input);
            
            // Step 2: Deep Neural Network threat classification
            DeepNeuralNetwork.ClassificationResult classification = 
                threatClassificationNetwork.classify(features);
            
            // Step 3: Anomaly detection using Isolation Forest
            IsolationForestAnomalyDetector.AnomalyResult anomaly = 
                anomalyDetector.detectAnomaly(features);
            
            // Step 4: Sequential pattern analysis using LSTM
            LSTMSequenceAnalyzer.SequenceResult sequence = 
                sequenceAnalyzer.analyzeSequence(input.getSequentialData());
            
            // Step 5: Ensemble prediction combining all models
            EnsemblePredictor.EnsembleResult ensemble = 
                ensemblePredictor.predict(classification, anomaly, sequence);
            
            // Step 6: Adaptive learning based on feedback
            learningEngine.updateModels(input, ensemble);
            
            // Create comprehensive AI detection result
            return createAiDetectionResult(input, classification, anomaly, sequence, ensemble);
            
        } catch (Exception e) {
            log.error("Error in AI threat detection for IP: {}", input.getIpAddress(), e);
            return createFallbackResult(input);
        }
    }

    /**
     * Extract comprehensive feature vector for AI models
     */
    private double[] extractFeatures(ThreatDetectionInput input) {
        List<Double> features = new ArrayList<>();
        
        // Geographic features
        features.add(normalizeLatitude(input.getLatitude()));
        features.add(normalizeLongitude(input.getLongitude()));
        features.add(encodeCountryRisk(input.getCountry()));
        
        // Network features
        features.add(input.getIsVpn() ? 1.0 : 0.0);
        features.add(input.getIsProxy() ? 1.0 : 0.0);
        features.add(input.getIsTor() ? 1.0 : 0.0);
        features.add(input.getIsHosting() ? 1.0 : 0.0);
        
        // Behavioral features
        features.add(normalizeRequestFrequency(input.getRequestFrequency()));
        features.add(normalizePayloadSize(input.getPayloadSize()));
        features.add(encodeUserAgent(input.getUserAgent()));
        features.add(encodeRequestPattern(input.getRequestPattern()));
        
        // Temporal features
        features.add(encodeTimeOfDay(input.getTimestamp()));
        features.add(encodeDayOfWeek(input.getTimestamp()));
        features.add(normalizeSessionDuration(input.getSessionDuration()));
        
        // Historical features
        features.add(normalizeThreatHistory(input.getHistoricalThreatCount()));
        features.add(normalizeReputationScore(input.getReputationScore()));
        
        // Advanced behavioral patterns
        features.add(calculateEntropyScore(input.getRequestPattern()));
        features.add(calculateSimilarityScore(input.getRequestSequence()));
        features.add(encodeProtocolDistribution(input.getProtocolUsage()));
        
        return features.stream().mapToDouble(Double::doubleValue).toArray();
    }

    /**
     * Deep Neural Network for threat classification
     */
    @Service
    public static class DeepNeuralNetwork {
        
        // Simulated neural network layers
        private double[][] weightsLayer1 = initializeWeights(17, 32); // Input to hidden1
        private double[][] weightsLayer2 = initializeWeights(32, 16); // Hidden1 to hidden2
        private double[][] weightsLayer3 = initializeWeights(16, 8);  // Hidden2 to hidden3
        private double[][] weightsOutput = initializeWeights(8, 5);   // Hidden3 to output
        
        private double[] biasLayer1 = initializeBias(32);
        private double[] biasLayer2 = initializeBias(16);
        private double[] biasLayer3 = initializeBias(8);
        private double[] biasOutput = initializeBias(5);

        public ClassificationResult classify(double[] inputFeatures) {
            try {
                // Forward propagation through deep network
                double[] hidden1 = relu(matrixMultiply(inputFeatures, weightsLayer1, biasLayer1));
                double[] hidden2 = relu(matrixMultiply(hidden1, weightsLayer2, biasLayer2));
                double[] hidden3 = relu(matrixMultiply(hidden2, weightsLayer3, biasLayer3));
                double[] output = softmax(matrixMultiply(hidden3, weightsOutput, biasOutput));
                
                // Interpret output neurons
                ThreatLocation.ThreatType predictedType = interpretThreatType(output);
                ThreatLocation.SeverityLevel predictedSeverity = interpretSeverity(output);
                double confidence = Arrays.stream(output).max().orElse(0.0);
                
                return new ClassificationResult(predictedType, predictedSeverity, confidence, output);
                
            } catch (Exception e) {
                log.error("Error in neural network classification", e);
                return new ClassificationResult(
                    ThreatLocation.ThreatType.UNKNOWN, 
                    ThreatLocation.SeverityLevel.MEDIUM, 
                    0.5, 
                    new double[5]
                );
            }
        }

        // Neural network utility methods
        private double[][] initializeWeights(int rows, int cols) {
            double[][] weights = new double[rows][cols];
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    weights[i][j] = ThreadLocalRandom.current().nextGaussian() * 0.1;
                }
            }
            return weights;
        }

        private double[] initializeBias(int size) {
            double[] bias = new double[size];
            for (int i = 0; i < size; i++) {
                bias[i] = ThreadLocalRandom.current().nextGaussian() * 0.01;
            }
            return bias;
        }

        private double[] matrixMultiply(double[] input, double[][] weights, double[] bias) {
            double[] result = new double[weights[0].length];
            for (int j = 0; j < weights[0].length; j++) {
                result[j] = bias[j];
                for (int i = 0; i < input.length; i++) {
                    result[j] += input[i] * weights[i][j];
                }
            }
            return result;
        }

        private double[] relu(double[] input) {
            return Arrays.stream(input).map(x -> Math.max(0, x)).toArray();
        }

        private double[] softmax(double[] input) {
            double max = Arrays.stream(input).max().orElse(0);
            double[] shifted = Arrays.stream(input).map(x -> x - max).toArray();
            double[] exp = Arrays.stream(shifted).map(Math::exp).toArray();
            double sum = Arrays.stream(exp).sum();
            return Arrays.stream(exp).map(x -> x / sum).toArray();
        }

        private ThreatLocation.ThreatType interpretThreatType(double[] output) {
            int maxIndex = 0;
            for (int i = 1; i < output.length - 1; i++) {
                if (output[i] > output[maxIndex]) {
                    maxIndex = i;
                }
            }
            
            return switch (maxIndex) {
                case 0 -> ThreatLocation.ThreatType.DATA_POISONING;
                case 1 -> ThreatLocation.ThreatType.ADVERSARIAL_ATTACK;
                case 2 -> ThreatLocation.ThreatType.MODEL_THEFT;
                case 3 -> ThreatLocation.ThreatType.INJECTION_ATTACK;
                default -> ThreatLocation.ThreatType.UNKNOWN;
            };
        }

        private ThreatLocation.SeverityLevel interpretSeverity(double[] output) {
            double severityScore = output[output.length - 1]; // Last neuron for severity
            
            if (severityScore > 0.8) return ThreatLocation.SeverityLevel.CRITICAL;
            if (severityScore > 0.6) return ThreatLocation.SeverityLevel.HIGH;
            if (severityScore > 0.4) return ThreatLocation.SeverityLevel.MEDIUM;
            return ThreatLocation.SeverityLevel.LOW;
        }

        public static class ClassificationResult {
            private final ThreatLocation.ThreatType threatType;
            private final ThreatLocation.SeverityLevel severity;
            private final double confidence;
            private final double[] rawOutput;

            public ClassificationResult(ThreatLocation.ThreatType threatType, 
                                      ThreatLocation.SeverityLevel severity, 
                                      double confidence, double[] rawOutput) {
                this.threatType = threatType;
                this.severity = severity;
                this.confidence = confidence;
                this.rawOutput = rawOutput;
            }

            // Getters
            public ThreatLocation.ThreatType getThreatType() { return threatType; }
            public ThreatLocation.SeverityLevel getSeverity() { return severity; }
            public double getConfidence() { return confidence; }
            public double[] getRawOutput() { return rawOutput; }
        }
    }

    /**
     * Isolation Forest for anomaly detection
     */
    @Service
    public static class IsolationForestAnomalyDetector {
        
        private List<IsolationTree> forest;
        private final int numTrees = 100;
        private final int subsampleSize = 256;

        public AnomalyResult detectAnomaly(double[] features) {
            try {
                if (forest == null) {
                    initializeForest();
                }

                double anomalyScore = calculateAnomalyScore(features);
                boolean isAnomaly = anomalyScore > 0.6; // Threshold for anomaly
                String explanation = generateAnomalyExplanation(features, anomalyScore);

                return new AnomalyResult(isAnomaly, anomalyScore, explanation);
                
            } catch (Exception e) {
                log.error("Error in anomaly detection", e);
                return new AnomalyResult(false, 0.0, "Error in anomaly detection");
            }
        }

        private void initializeForest() {
            forest = new ArrayList<>();
            for (int i = 0; i < numTrees; i++) {
                forest.add(new IsolationTree(subsampleSize));
            }
        }

        private double calculateAnomalyScore(double[] features) {
            double avgPathLength = forest.stream()
                .mapToDouble(tree -> tree.getPathLength(features))
                .average()
                .orElse(0.0);
            
            // Normalize path length to anomaly score (0-1)
            double expectedAvgPath = expectedAveragePathLength(subsampleSize);
            return Math.pow(2, -avgPathLength / expectedAvgPath);
        }

        private double expectedAveragePathLength(int n) {
            if (n <= 1) return 0;
            return 2.0 * (Math.log(n - 1) + 0.5772156649) - (2.0 * (n - 1) / n);
        }

        private String generateAnomalyExplanation(double[] features, double score) {
            List<String> factors = new ArrayList<>();
            
            // Analyze which features contribute most to anomaly
            if (features[3] > 0.5) factors.add("VPN usage detected");
            if (features[4] > 0.5) factors.add("Proxy usage detected");
            if (features[5] > 0.5) factors.add("Tor usage detected");
            if (features[7] > 0.8) factors.add("High request frequency");
            if (features[13] > 0.7) factors.add("Poor reputation score");
            
            if (factors.isEmpty()) {
                return String.format("Anomaly score: %.3f - General behavioral anomaly", score);
            }
            
            return String.format("Anomaly score: %.3f - Factors: %s", 
                               score, String.join(", ", factors));
        }

        // Simplified Isolation Tree implementation
        private static class IsolationTree {
            private TreeNode root;
            private final int maxDepth;

            public IsolationTree(int subsampleSize) {
                this.maxDepth = (int) Math.ceil(Math.log(subsampleSize) / Math.log(2));
                // In practice, this would be built from training data
                this.root = buildRandomTree(0);
            }

            private TreeNode buildRandomTree(int depth) {
                if (depth >= maxDepth) {
                    return new TreeNode(true, 0, 0.0, null, null);
                }

                int splitFeature = ThreadLocalRandom.current().nextInt(17); // Number of features
                double splitValue = ThreadLocalRandom.current().nextDouble();
                
                return new TreeNode(false, splitFeature, splitValue,
                    buildRandomTree(depth + 1), buildRandomTree(depth + 1));
            }

            public double getPathLength(double[] features) {
                return getPathLength(root, features, 0);
            }

            private double getPathLength(TreeNode node, double[] features, int depth) {
                if (node.isLeaf) {
                    return depth + expectedAveragePathLength(1); // Estimate for remaining path
                }

                if (features[node.splitFeature] < node.splitValue) {
                    return getPathLength(node.left, features, depth + 1);
                } else {
                    return getPathLength(node.right, features, depth + 1);
                }
            }

            private double expectedAveragePathLength(int n) {
                if (n <= 1) return 0;
                return 2.0 * (Math.log(n - 1) + 0.5772156649) - (2.0 * (n - 1) / n);
            }

            private static class TreeNode {
                boolean isLeaf;
                int splitFeature;
                double splitValue;
                TreeNode left, right;

                TreeNode(boolean isLeaf, int splitFeature, double splitValue, TreeNode left, TreeNode right) {
                    this.isLeaf = isLeaf;
                    this.splitFeature = splitFeature;
                    this.splitValue = splitValue;
                    this.left = left;
                    this.right = right;
                }
            }
        }

        public static class AnomalyResult {
            private final boolean isAnomaly;
            private final double anomalyScore;
            private final String explanation;

            public AnomalyResult(boolean isAnomaly, double anomalyScore, String explanation) {
                this.isAnomaly = isAnomaly;
                this.anomalyScore = anomalyScore;
                this.explanation = explanation;
            }

            // Getters
            public boolean isAnomaly() { return isAnomaly; }
            public double getAnomalyScore() { return anomalyScore; }
            public String getExplanation() { return explanation; }
        }
    }

    /**
     * LSTM Network for sequential pattern analysis
     */
    @Service
    public static class LSTMSequenceAnalyzer {
        
        private final int hiddenSize = 64;
        private final int sequenceLength = 10;
        
        // Simplified LSTM cell parameters
        private double[][] forgetGateWeights = initializeMatrix(hiddenSize, hiddenSize + 1);
        private double[][] inputGateWeights = initializeMatrix(hiddenSize, hiddenSize + 1);
        private double[][] candidateWeights = initializeMatrix(hiddenSize, hiddenSize + 1);
        private double[][] outputGateWeights = initializeMatrix(hiddenSize, hiddenSize + 1);

        public SequenceResult analyzeSequence(List<Map<String, Object>> sequentialData) {
            try {
                if (sequentialData == null || sequentialData.isEmpty()) {
                    return new SequenceResult(false, 0.0, "No sequential data available");
                }

                // Convert sequential data to feature vectors
                List<double[]> sequence = sequentialData.stream()
                    .limit(sequenceLength)
                    .map(this::extractSequenceFeatures)
                    .collect(Collectors.toList());

                // LSTM forward pass
                double[] finalHiddenState = processSequence(sequence);
                
                // Analyze patterns
                double patternScore = analyzePatternComplexity(finalHiddenState);
                boolean suspiciousPattern = patternScore > 0.7;
                String patternDescription = describePattern(finalHiddenState, patternScore);

                return new SequenceResult(suspiciousPattern, patternScore, patternDescription);
                
            } catch (Exception e) {
                log.error("Error in LSTM sequence analysis", e);
                return new SequenceResult(false, 0.0, "Error in sequence analysis");
            }
        }

        private double[] extractSequenceFeatures(Map<String, Object> dataPoint) {
            // Extract features from each data point in sequence
            double[] features = new double[10]; // Simplified feature set
            
            features[0] = getDoubleValue(dataPoint, "timestamp_normalized");
            features[1] = getDoubleValue(dataPoint, "request_size");
            features[2] = getDoubleValue(dataPoint, "response_time");
            features[3] = getDoubleValue(dataPoint, "error_rate");
            features[4] = getDoubleValue(dataPoint, "payload_entropy");
            features[5] = getDoubleValue(dataPoint, "connection_count");
            features[6] = getDoubleValue(dataPoint, "protocol_variation");
            features[7] = getDoubleValue(dataPoint, "geographic_consistency");
            features[8] = getDoubleValue(dataPoint, "behavioral_score");
            features[9] = getDoubleValue(dataPoint, "anomaly_indicator");
            
            return features;
        }

        private double getDoubleValue(Map<String, Object> map, String key) {
            Object value = map.get(key);
            if (value instanceof Number) {
                return ((Number) value).doubleValue();
            }
            return ThreadLocalRandom.current().nextDouble(); // Mock data
        }

        private double[] processSequence(List<double[]> sequence) {
            double[] hiddenState = new double[hiddenSize];
            double[] cellState = new double[hiddenSize];

            for (double[] input : sequence) {
                // LSTM cell computation (simplified)
                double[] combined = combineInputHidden(input, hiddenState);
                
                double[] forgetGate = sigmoid(matrixVectorMultiply(forgetGateWeights, combined));
                double[] inputGate = sigmoid(matrixVectorMultiply(inputGateWeights, combined));
                double[] candidate = tanh(matrixVectorMultiply(candidateWeights, combined));
                double[] outputGate = sigmoid(matrixVectorMultiply(outputGateWeights, combined));

                // Update cell state
                for (int i = 0; i < hiddenSize; i++) {
                    cellState[i] = forgetGate[i] * cellState[i] + inputGate[i] * candidate[i];
                    hiddenState[i] = outputGate[i] * Math.tanh(cellState[i]);
                }
            }

            return hiddenState;
        }

        private double[] combineInputHidden(double[] input, double[] hidden) {
            double[] combined = new double[input.length + hidden.length];
            System.arraycopy(input, 0, combined, 0, input.length);
            System.arraycopy(hidden, 0, combined, input.length, hidden.length);
            return combined;
        }

        private double[][] initializeMatrix(int rows, int cols) {
            double[][] matrix = new double[rows][cols];
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    matrix[i][j] = ThreadLocalRandom.current().nextGaussian() * 0.1;
                }
            }
            return matrix;
        }

        private double[] matrixVectorMultiply(double[][] matrix, double[] vector) {
            double[] result = new double[matrix.length];
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < vector.length; j++) {
                    result[i] += matrix[i][j] * vector[j];
                }
            }
            return result;
        }

        private double[] sigmoid(double[] input) {
            return Arrays.stream(input).map(x -> 1.0 / (1.0 + Math.exp(-x))).toArray();
        }

        private double[] tanh(double[] input) {
            return Arrays.stream(input).map(Math::tanh).toArray();
        }

        private double analyzePatternComplexity(double[] hiddenState) {
            // Analyze hidden state to determine pattern complexity/suspiciousness
            double variance = calculateVariance(hiddenState);
            double entropy = calculateEntropy(hiddenState);
            double activation = Arrays.stream(hiddenState).map(Math::abs).average().orElse(0.0);
            
            return Math.min(1.0, (variance * 0.4 + entropy * 0.4 + activation * 0.2));
        }

        private double calculateVariance(double[] values) {
            double mean = Arrays.stream(values).average().orElse(0.0);
            double variance = Arrays.stream(values)
                .map(x -> Math.pow(x - mean, 2))
                .average()
                .orElse(0.0);
            return Math.sqrt(variance);
        }

        private double calculateEntropy(double[] values) {
            // Simplified entropy calculation
            double sum = Arrays.stream(values).map(Math::abs).sum();
            if (sum == 0) return 0;
            
            return Arrays.stream(values)
                .map(Math::abs)
                .map(x -> x / sum)
                .filter(p -> p > 0)
                .mapToDouble(p -> -p * Math.log(p))
                .sum() / Math.log(2);
        }

        private String describePattern(double[] hiddenState, double score) {
            if (score > 0.8) return "Highly irregular sequence pattern detected";
            if (score > 0.6) return "Moderate sequence anomaly identified";
            if (score > 0.4) return "Minor sequence irregularity observed";
            return "Normal sequence pattern";
        }

        public static class SequenceResult {
            private final boolean suspiciousPattern;
            private final double patternScore;
            private final String description;

            public SequenceResult(boolean suspiciousPattern, double patternScore, String description) {
                this.suspiciousPattern = suspiciousPattern;
                this.patternScore = patternScore;
                this.description = description;
            }

            // Getters
            public boolean isSuspiciousPattern() { return suspiciousPattern; }
            public double getPatternScore() { return patternScore; }
            public String getDescription() { return description; }
        }
    }

    // Feature extraction utility methods
    private double normalizeLatitude(Double latitude) {
        return latitude != null ? (latitude + 90.0) / 180.0 : 0.5;
    }

    private double normalizeLongitude(Double longitude) {
        return longitude != null ? (longitude + 180.0) / 360.0 : 0.5;
    }

    private double encodeCountryRisk(String country) {
        Map<String, Double> countryRisks = Map.of(
            "Unknown", 0.8,
            "North Korea", 1.0,
            "Iran", 0.7,
            "Russia", 0.6,
            "China", 0.6,
            "United States", 0.2,
            "Germany", 0.1,
            "Japan", 0.1
        );
        return countryRisks.getOrDefault(country, 0.3);
    }

    private double normalizeRequestFrequency(Integer frequency) {
        return frequency != null ? Math.min(1.0, frequency / 1000.0) : 0.0;
    }

    private double normalizePayloadSize(Long size) {
        return size != null ? Math.min(1.0, size / 1048576.0) : 0.0; // Normalize to 1MB
    }

    private double encodeUserAgent(String userAgent) {
        if (userAgent == null) return 0.5;
        String ua = userAgent.toLowerCase();
        if (ua.contains("bot") || ua.contains("crawler")) return 0.8;
        if (ua.contains("curl") || ua.contains("wget")) return 0.9;
        if (ua.contains("python") || ua.contains("requests")) return 0.7;
        return 0.3;
    }

    private double encodeRequestPattern(String pattern) {
        if (pattern == null) return 0.5;
        // Analyze request pattern characteristics
        if (pattern.contains("injection") || pattern.contains("script")) return 0.9;
        if (pattern.contains("admin") || pattern.contains("config")) return 0.7;
        return 0.3;
    }

    private double encodeTimeOfDay(LocalDateTime timestamp) {
        if (timestamp == null) return 0.5;
        int hour = timestamp.getHour();
        // Suspicious hours (late night/early morning)
        if (hour >= 2 && hour <= 5) return 0.8;
        if (hour >= 22 || hour <= 1) return 0.6;
        return 0.3;
    }

    private double encodeDayOfWeek(LocalDateTime timestamp) {
        if (timestamp == null) return 0.5;
        int dayOfWeek = timestamp.getDayOfWeek().getValue();
        // Weekend activity might be more suspicious
        return (dayOfWeek >= 6) ? 0.6 : 0.4;
    }

    private double normalizeSessionDuration(Long duration) {
        return duration != null ? Math.min(1.0, duration / 3600.0) : 0.0; // Normalize to 1 hour
    }

    private double normalizeThreatHistory(Integer count) {
        return count != null ? Math.min(1.0, count / 100.0) : 0.0;
    }

    private double normalizeReputationScore(Double score) {
        return score != null ? (100.0 - score) / 100.0 : 0.5; // Invert so high=bad
    }

    private double calculateEntropyScore(String pattern) {
        if (pattern == null || pattern.isEmpty()) return 0.0;
        
        Map<Character, Integer> frequency = new HashMap<>();
        for (char c : pattern.toCharArray()) {
            frequency.merge(c, 1, Integer::sum);
        }
        
        double entropy = 0.0;
        int length = pattern.length();
        for (int freq : frequency.values()) {
            double probability = (double) freq / length;
            entropy -= probability * Math.log(probability) / Math.log(2);
        }
        
        return Math.min(1.0, entropy / 8.0); // Normalize
    }

    private double calculateSimilarityScore(List<String> sequence) {
        if (sequence == null || sequence.size() < 2) return 0.0;
        
        // Calculate average Levenshtein distance between consecutive requests
        double totalSimilarity = 0.0;
        for (int i = 1; i < sequence.size(); i++) {
            totalSimilarity += calculateLevenshteinSimilarity(sequence.get(i-1), sequence.get(i));
        }
        
        return totalSimilarity / (sequence.size() - 1);
    }

    private double calculateLevenshteinSimilarity(String s1, String s2) {
        if (s1 == null || s2 == null) return 0.0;
        
        int maxLen = Math.max(s1.length(), s2.length());
        if (maxLen == 0) return 1.0;
        
        int distance = levenshteinDistance(s1, s2);
        return 1.0 - ((double) distance / maxLen);
    }

    private int levenshteinDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) dp[i][0] = i;
        for (int j = 0; j <= s2.length(); j++) dp[0][j] = j;
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                int cost = (s1.charAt(i-1) == s2.charAt(j-1)) ? 0 : 1;
                dp[i][j] = Math.min(
                    Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1),
                    dp[i-1][j-1] + cost
                );
            }
        }
        
        return dp[s1.length()][s2.length()];
    }

    private double encodeProtocolDistribution(Map<String, Integer> protocolUsage) {
        if (protocolUsage == null || protocolUsage.isEmpty()) return 0.5;
        
        int total = protocolUsage.values().stream().mapToInt(Integer::intValue).sum();
        
        // Calculate protocol diversity (higher diversity = more suspicious)
        double entropy = 0.0;
        for (int count : protocolUsage.values()) {
            double probability = (double) count / total;
            if (probability > 0) {
                entropy -= probability * Math.log(probability) / Math.log(2);
            }
        }
        
        return Math.min(1.0, entropy / 3.0); // Normalize
    }

    // Additional AI components would be implemented here...
    // EnsemblePredictor, AdaptiveLearningEngine, etc.

    // Placeholder implementations for compilation
    @Service
    public static class EnsemblePredictor {
        public EnsembleResult predict(DeepNeuralNetwork.ClassificationResult classification,
                                    IsolationForestAnomalyDetector.AnomalyResult anomaly,
                                    LSTMSequenceAnalyzer.SequenceResult sequence) {
            // Combine predictions from all models
            double combinedScore = (classification.getConfidence() * 0.4 + 
                                  anomaly.getAnomalyScore() * 0.3 + 
                                  sequence.getPatternScore() * 0.3);
            
            return new EnsembleResult(combinedScore > 0.7, combinedScore, 
                "Ensemble prediction based on neural network, anomaly detection, and sequence analysis");
        }

        public static class EnsembleResult {
            private final boolean isThreat;
            private final double confidence;
            private final String explanation;

            public EnsembleResult(boolean isThreat, double confidence, String explanation) {
                this.isThreat = isThreat;
                this.confidence = confidence;
                this.explanation = explanation;
            }

            public boolean isThreat() { return isThreat; }
            public double getConfidence() { return confidence; }
            public String getExplanation() { return explanation; }
        }
    }

    @Service
    public static class AdaptiveLearningEngine {
        public void updateModels(ThreatDetectionInput input, EnsemblePredictor.EnsembleResult result) {
            // Implement online learning/model updates based on feedback
            log.debug("Updating AI models based on feedback for IP: {}", input.getIpAddress());
        }
    }

    // Result classes
    private AiThreatDetectionResult createAiDetectionResult(ThreatDetectionInput input,
                                                           DeepNeuralNetwork.ClassificationResult classification,
                                                           IsolationForestAnomalyDetector.AnomalyResult anomaly,
                                                           LSTMSequenceAnalyzer.SequenceResult sequence,
                                                           EnsemblePredictor.EnsembleResult ensemble) {
        return new AiThreatDetectionResult(
            input.getIpAddress(),
            ensemble.isThreat(),
            ensemble.getConfidence(),
            classification.getThreatType(),
            classification.getSeverity(),
            anomaly.isAnomaly(),
            anomaly.getAnomalyScore(),
            sequence.isSuspiciousPattern(),
            sequence.getPatternScore(),
            generateDetailedExplanation(classification, anomaly, sequence, ensemble),
            LocalDateTime.now()
        );
    }

    private AiThreatDetectionResult createFallbackResult(ThreatDetectionInput input) {
        return new AiThreatDetectionResult(
            input.getIpAddress(),
            false,
            0.5,
            ThreatLocation.ThreatType.UNKNOWN,
            ThreatLocation.SeverityLevel.LOW,
            false,
            0.0,
            false,
            0.0,
            "AI detection disabled - using fallback classification",
            LocalDateTime.now()
        );
    }

    private String generateDetailedExplanation(DeepNeuralNetwork.ClassificationResult classification,
                                             IsolationForestAnomalyDetector.AnomalyResult anomaly,
                                             LSTMSequenceAnalyzer.SequenceResult sequence,
                                             EnsemblePredictor.EnsembleResult ensemble) {
        StringBuilder explanation = new StringBuilder();
        explanation.append("AI Analysis Results:\n");
        explanation.append(String.format("- Neural Network: %s (%.2f%% confidence)\n", 
            classification.getThreatType(), classification.getConfidence() * 100));
        explanation.append(String.format("- Anomaly Detection: %s (score: %.3f)\n", 
            anomaly.getExplanation(), anomaly.getAnomalyScore()));
        explanation.append(String.format("- Sequence Analysis: %s (score: %.3f)\n", 
            sequence.getDescription(), sequence.getPatternScore()));
        explanation.append(String.format("- Ensemble Decision: %s (%.2f%% confidence)", 
            ensemble.getExplanation(), ensemble.getConfidence() * 100));
        
        return explanation.toString();
    }

    // Input and output classes for AI threat detection
    public static class ThreatDetectionInput {
        private String ipAddress;
        private String country;
        private Double latitude;
        private Double longitude;
        private Boolean isVpn;
        private Boolean isProxy;
        private Boolean isTor;
        private Boolean isHosting;
        private Integer requestFrequency;
        private Long payloadSize;
        private String userAgent;
        private String requestPattern;
        private LocalDateTime timestamp;
        private Long sessionDuration;
        private Integer historicalThreatCount;
        private Double reputationScore;
        private List<String> requestSequence;
        private Map<String, Integer> protocolUsage;
        private List<Map<String, Object>> sequentialData;

        // Constructors, getters, and setters
        public ThreatDetectionInput() {}

        // Getters and setters for all fields...
        public String getIpAddress() { return ipAddress; }
        public void setIpAddress(String ipAddress) { this.ipAddress = ipAddress; }
        
        public String getCountry() { return country; }
        public void setCountry(String country) { this.country = country; }
        
        public Double getLatitude() { return latitude; }
        public void setLatitude(Double latitude) { this.latitude = latitude; }
        
        public Double getLongitude() { return longitude; }
        public void setLongitude(Double longitude) { this.longitude = longitude; }
        
        public Boolean getIsVpn() { return isVpn; }
        public void setIsVpn(Boolean isVpn) { this.isVpn = isVpn; }
        
        public Boolean getIsProxy() { return isProxy; }
        public void setIsProxy(Boolean isProxy) { this.isProxy = isProxy; }
        
        public Boolean getIsTor() { return isTor; }
        public void setIsTor(Boolean isTor) { this.isTor = isTor; }
        
        public Boolean getIsHosting() { return isHosting; }
        public void setIsHosting(Boolean isHosting) { this.isHosting = isHosting; }
        
        public Integer getRequestFrequency() { return requestFrequency; }
        public void setRequestFrequency(Integer requestFrequency) { this.requestFrequency = requestFrequency; }
        
        public Long getPayloadSize() { return payloadSize; }
        public void setPayloadSize(Long payloadSize) { this.payloadSize = payloadSize; }
        
        public String getUserAgent() { return userAgent; }
        public void setUserAgent(String userAgent) { this.userAgent = userAgent; }
        
        public String getRequestPattern() { return requestPattern; }
        public void setRequestPattern(String requestPattern) { this.requestPattern = requestPattern; }
        
        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
        
        public Long getSessionDuration() { return sessionDuration; }
        public void setSessionDuration(Long sessionDuration) { this.sessionDuration = sessionDuration; }
        
        public Integer getHistoricalThreatCount() { return historicalThreatCount; }
        public void setHistoricalThreatCount(Integer historicalThreatCount) { this.historicalThreatCount = historicalThreatCount; }
        
        public Double getReputationScore() { return reputationScore; }
        public void setReputationScore(Double reputationScore) { this.reputationScore = reputationScore; }
        
        public List<String> getRequestSequence() { return requestSequence; }
        public void setRequestSequence(List<String> requestSequence) { this.requestSequence = requestSequence; }
        
        public Map<String, Integer> getProtocolUsage() { return protocolUsage; }
        public void setProtocolUsage(Map<String, Integer> protocolUsage) { this.protocolUsage = protocolUsage; }
        
        public List<Map<String, Object>> getSequentialData() { return sequentialData; }
        public void setSequentialData(List<Map<String, Object>> sequentialData) { this.sequentialData = sequentialData; }
    }

    public static class AiThreatDetectionResult {
        private String ipAddress;
        private boolean isThreat;
        private double confidence;
        private ThreatLocation.ThreatType threatType;
        private ThreatLocation.SeverityLevel severity;
        private boolean isAnomaly;
        private double anomalyScore;
        private boolean suspiciousPattern;
        private double patternScore;
        private String explanation;
        private LocalDateTime analysisTimestamp;

        public AiThreatDetectionResult(String ipAddress, boolean isThreat, double confidence,
                                     ThreatLocation.ThreatType threatType, ThreatLocation.SeverityLevel severity,
                                     boolean isAnomaly, double anomalyScore, boolean suspiciousPattern,
                                     double patternScore, String explanation, LocalDateTime analysisTimestamp) {
            this.ipAddress = ipAddress;
            this.isThreat = isThreat;
            this.confidence = confidence;
            this.threatType = threatType;
            this.severity = severity;
            this.isAnomaly = isAnomaly;
            this.anomalyScore = anomalyScore;
            this.suspiciousPattern = suspiciousPattern;
            this.patternScore = patternScore;
            this.explanation = explanation;
            this.analysisTimestamp = analysisTimestamp;
        }

        // Getters
        public String getIpAddress() { return ipAddress; }
        public boolean isThreat() { return isThreat; }
        public double getConfidence() { return confidence; }
        public ThreatLocation.ThreatType getThreatType() { return threatType; }
        public ThreatLocation.SeverityLevel getSeverity() { return severity; }
        public boolean isAnomaly() { return isAnomaly; }
        public double getAnomalyScore() { return anomalyScore; }
        public boolean isSuspiciousPattern() { return suspiciousPattern; }
        public double getPatternScore() { return patternScore; }
        public String getExplanation() { return explanation; }
        public LocalDateTime getAnalysisTimestamp() { return analysisTimestamp; }
    }
}